<!DOCTYPE html>
<html>
<body>


  <meta charset="utf-8">
  <title>Opus Hardware – Vista Designer (beta)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">

  <!-- j        <div>
          <label>Fixing type</label>
          <select id="fixingType">
            <option value="">– select –</option>
            <option value="Concrete">Concrete</option>
            <option value="Steel">Steel</option>
            <option value="Timber (Coach Screw)">Timber (Coach Screw)</option>
            <option value="Timber (Bolt Through)">Timber (Bolt Through)</option>
          </select>
        </div> PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    :root {
      --bg: #fcfcf8;
      --card: #fff;
      --text: #222;
      --primary: #111;
      --accent: #0077c8;
      --border: #eaeaea;
      --radius: 12px;
    }
    * { box-sizing:border-box }
    html,body { margin:0;padding:0;font-family:system-ui,Arial,sans-serif;background:var(--bg);color:var(--text) }
    h1 { 
      font: 700 2.2rem/1.2 'Inter', system-ui, Arial, sans-serif;
      text-align: center;
      margin: 0;
      color: #2c3e50;
      letter-spacing: 0.02em;
      background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .title-card {
      background: linear-gradient(135deg, #ffffff 0%, #f8fafe 100%);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      padding: 2.5rem;
      margin: 2rem 0;
      text-align: center;
      position: relative;
      border: 1px solid #e3f2fd;
      overflow: hidden;
    }
    
    .title-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #0077c8, #3498db, #0077c8);
      border-radius: 20px 20px 0 0;
    }
    
    .title-card .beta-badge {
      display: inline-block;
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
      color: white;
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      margin-left: 1rem;
      box-shadow: 0 2px 8px rgba(255,107,107,0.3);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .title-card .subtitle {
      color: #64748b;
      font-size: 1.1rem;
      margin-top: 0.5rem;
      font-weight: 400;
      opacity: 0.8;
    }
    h2 {
      font: 600 1.5rem/1.2 'Inter', system-ui, Arial, sans-serif;
      text-align: center;
      margin: 0 0 1.5rem 0;
      color: #2c3e50;
      letter-spacing: 0.02em;
    }
    .container { max-width:960px;margin:auto;padding:0 1rem 4rem }
    .card { 
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border-radius: 16px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.08);
      padding: 2.5rem;
      margin-top: 2rem;
      position: relative;
      border: 1px solid #e9ecef;
    }
    label { font-weight:600;margin-top:.8rem;display:block }
    input[type="number"], select { 
      width: 100%;
      padding: .5rem;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: #fafaf7;
      font-size: 1rem;
      margin-bottom: 0.8em;
    }
    /* force checkboxes to appear in Shopify */
    input[type="checkbox"] {
      -webkit-appearance:checkbox;
      appearance:checkbox;
      display:inline-block;
      width:auto;
      margin-right:.5rem;
      vertical-align:middle;
    }
    /* default buttons are full‑width… */
    button { 
      display: block;
      width: 100%;
      margin-top: 2rem;
      padding: 1rem 2rem;
      font: 600 1.1rem 'Inter', system-ui, Arial, sans-serif;
      color: #fff;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      letter-spacing: 0.03em;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, #0077c8 0%, #005fa3 100%);
      box-shadow: 0 4px 12px rgba(0,119,200,0.3);
    }
    button:not([disabled]):hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,119,200,0.4);
      background: linear-gradient(135deg, #005fa3 0%, #004a82 100%);
    }
    button:not([disabled]) { 
      background: linear-gradient(135deg, #0077c8 0%, #005fa3 100%);
    }
    button[disabled] { 
      background: linear-gradient(135deg, #d0d0d0 0%, #bbb 100%);
      color: #666;
      cursor: not-allowed;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      transform: none;
    }
    /* back button override */
    #backBtn {
      width:auto!important;
      display:inline-block!important;
      background:#6c757d;
      position:absolute; top:1rem; right:1rem; padding:.35rem .9rem; font-size:.8rem;
    }
    #backBtn:hover { background:#565e64 }
    #calcBtn { background:#000 }    #calcBtn:hover { background:#333 }
    #emailBtn { background:#28a745 } #emailBtn:hover { background:#218838 }
    #viewBtn  { background:#0d6efd } #viewBtn:hover  { background:#0b5ed7 }
    #pdfBtn   { background:#0077c8 } #pdfBtn:hover   { background:#0062a8 }
    #view3dBtn { background:#28a745 } #view3dBtn:hover { background:#1e7e34 }
    /* Glass Order PDF button styling matches other primary action buttons */
    #orderPdfBtn {
      background: #0077c8;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      padding: 10px 20px;
      cursor: pointer;
      flex: 1;
    }
    #orderPdfBtn:hover {
      background: #0062a8;
    }
    .flexBtns { display:flex;gap:.8rem;margin-top:1rem }
    .results-table,.order-table { width:100%;border-collapse:collapse;margin-top:1rem }
    .results-table th,.results-table td,
    .order-table th,.order-table td { border:1px solid #ddd;padding:.5rem;text-align:center }
    .results-table th,.order-table th { background:#f0f0f0 }
    @media(min-width:640px){ .grid { display:grid;grid-template-columns:repeat(2,1fr);gap:1rem } }
    /* shape‐picker tiles */
    #shapeGrid { display:grid;grid-template-columns:repeat(4,1fr);gap:1.5rem;margin-top:2rem;max-width:1000px;margin-left:auto;margin-right:auto }
    .shape-card { 
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      border: 2px solid #e9ecef;
      border-radius: 16px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      position: relative;
      overflow: hidden;
      aspect-ratio: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    .shape-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #0077c8, #28a745, #0077c8);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .shape-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
      border-color: #0077c8;
    }
    .shape-card:hover::before {
      opacity: 1;
    }
    .shape-card.selected { 
      border-color: #0077c8;
      box-shadow: 0 8px 25px rgba(0,119,200,0.2);
      background: linear-gradient(135deg, #f8fbff 0%, #e8f4ff 100%);
    }
    .shape-card.selected::before {
      opacity: 1;
    }
    .shape-card img { 
      width: 100%;
      height: 150px;
      object-fit: contain;
      border-radius: 8px;
      background: linear-gradient(135deg, #f7f9fc 0%, #eef2f7 100%);
      padding: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .shape-card p { 
      text-align: center;
      margin: 0.5rem 0 0;
      font-weight: 600;
      font-size: 1.1rem;
      color: #2c3e50;
      letter-spacing: 0.02em;
    }
    /* make only the little panel‐view scroll, not the whole page */
    .view { overflow-x:auto }
    /* --- Add below your existing :root or at the end of <style> --- */
:root {
  --bg: #fcfcf8;
  --card: #fff;
  --text: #222;
  --primary: #111;
  --accent: #0077c8;
  --border: #eaeaea;
  --radius: 12px;
}

body, html {
  background: var(--bg);
  color: var(--text);
}

.card {
  background: var(--card);
  border-radius: var(--radius);
  box-shadow: 0 2px 8px rgba(0,0,0,0.04);
  border: 1px solid var(--border);
}

h1, h2 {
  font-family: 'Inter', system-ui, Arial, sans-serif;
  font-weight: 600;
  color: var(--primary);
  letter-spacing: 0.01em;
}

label {
  font-weight: 500;
  color: var(--primary);
  margin-bottom: 0.3em;
}

input[type="number"], select {
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: #fafaf7;
  font-size: 1rem;
  padding: 0.6em;
  margin-bottom: 0.8em;
}

button {
  background: var(--primary);
  color: #fff;
  border-radius: var(--radius);
  font-weight: 600;
  letter-spacing: 0.03em;
  transition: background 0.2s;
}

button:not([disabled]):hover {
  background: var(--accent);
}

.results-table th, .order-table th {
  background: #f7f7f7;
  color: var(--primary);
  font-weight: 500;
}

.results-table td, .order-table td {
  background: #fff;
  color: var(--text);
}

.shape-card {
  border: 1px solid var(--border);
  box-shadow: none;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.shape-card.selected {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px var(--accent);
}

.shape-card img {
  border-radius: var(--radius);
  background: #f7f7f7;
}

.flexBtns button {
  background: var(--accent);
  color: #fff;
}

.flexBtns button:hover {
  background: #005fa3;
}

/* Hide stray logos outside main container */
body > img[src*="opus"],
body > img[src*="logo"],
.site-header img,
.header-logo,
.logo:not(.container .logo),
body > div:first-child img {
  display: none !important;
}

/* More aggressive logo hiding */
body > *:not(.container) img[src*="logo"],
body > *:not(.container) img[src*="opus"] {
  display: none !important;
}
    .disc-head-card {
      background:#fff;
      border:2px solid #ccc;
      border-radius:12px;
      padding:8px 10px 4px 10px;
      cursor:pointer;
      transition:.2s;
      box-shadow:0 2px 6px rgba(0,0,0,.07);
      outline:none;
      width:110px;
      text-align:center;
      display:flex;
      flex-direction:column;
      align-items:center;
    }
    .disc-head-card.selected {
      border-color:#0077c8;
      box-shadow:0 0 0 3px #0077c84a;
    }
    .disc-head-card:focus {
      border-color:#0077c8;
      box-shadow:0 0 0 3px #0077c84a;
    }
    #powdercoatColor {
      display: none;
      margin-top: 0.5rem;
    }
    
    /* Gate Control Button Styles - Black Design */
    .liveGateLeft, .liveGateRight, .liveGateFlip {
      /* Unified gate control button styling (compact) */
      background: #000 !important;
      border: 1px solid #333 !important;
      border-radius: 4px !important;
      color: #ffffff !important;
      cursor: pointer !important;
      font-weight: 500 !important;
      font-size: 0.85rem !important;
      padding: 0.4rem 0.5rem !important;
      transition: background 0.25s ease, box-shadow 0.25s ease, transform 0.25s ease !important;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: flex-start !important;
      gap: 0.6rem !important;
      min-height: 36px !important;
      width: auto !important;
      min-width: 0 !important;
      white-space: nowrap !important;
    }
    
    .liveGateLeft:hover, .liveGateRight:hover, .liveGateFlip:hover {
      background: #34495e !important;
      transform: translateY(-1px) !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25) !important;
      border-color: #4a6741 !important;
    }
    
    .liveGateLeft:active, .liveGateRight:active, .liveGateFlip:active {
      transform: translateY(0) !important;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2) !important;
      background: #1a252f !important;
    }
    
    .liveGateLeft:disabled, .liveGateRight:disabled {
      opacity: 0.4 !important;
      cursor: not-allowed !important;
      transform: none !important;
      background: #7f8c8d !important;
      color: #bdc3c7 !important;
      border-color: #95a5a6 !important;
    }
    
    .liveGateLeft:disabled:hover, .liveGateRight:disabled:hover {
      background: #7f8c8d !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
      transform: none !important;
      border-color: #95a5a6 !important;
    }
    
    /* Icon and label styling for gate control buttons */
    .liveGateLeft .icon, .liveGateRight .icon, .liveGateFlip .icon {
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      width: 20px !important;
      height: 20px !important;
      line-height: 20px !important;
      border-radius: 50% !important;
      background: #ffffff !important;
      color: #000000 !important;
      font-size: 0.75rem !important;
      font-weight: 600 !important;
      flex-shrink: 0 !important;
    }
    .liveGateLeft .label, .liveGateRight .label, .liveGateFlip .label {
      color: #ffffff !important;
      font-size: 0.75rem !important;
      font-weight: 500 !important;
      white-space: nowrap !important;
    }
  </style>



<div class="container">
  
  <div class="title-card">
    <h1 id="mainTitle" style="display:flex;align-items:center;justify-content:center;gap:1.5rem;">
      <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/Vista_Channel_Thumbnail.png?v=1753411651" alt="Vista Channel" style="width:80px;height:80px;object-fit:contain;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.15);display:block!important;" onload="console.log('Vista image loaded successfully')" onerror="console.log('Failed to load Vista image, trying fallback'); this.src='https://via.placeholder.com/80x80/0077c8/ffffff?text=Vista';">
      Opus Hardware – Vista Designer
      <span class="beta-badge">Beta</span>
    </h1>
    <p class="subtitle">Professional fence design and calculation tool</p>
  </div>
  <!-- SHAPE PICKER -->
    <div id="shapePicker" class="card">
      <h2 style="text-align:center;font-size:1.8rem;margin-bottom:1.5rem;color:#2c3e50;">
        Select Fence Shape
      </h2>
      <div id="shapeGrid">
        <div class="shape-card" data-id="INLINE">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/inline_png.png?v=1752528420" alt="Inline" style="display:block!important;" onload="console.log('Inline image loaded successfully')" onerror="console.log('Failed to load Inline image, using fallback'); this.src='data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'200\' height=\'200\' viewBox=\'0 0 200 200\'%3E%3Crect width=\'200\' height=\'200\' fill=\'%23f0f0f0\'/%3E%3Ctext x=\'100\' y=\'100\' text-anchor=\'middle\' dy=\'0.3em\' font-family=\'Arial\' font-size=\'16\' fill=\'%23666\'%3EInline%3C/text%3E%3C/svg%3E';">
          <p>Inline</p>
        </div>
        <div class="shape-card" data-id="L">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/lshaped_png.png?v=1752528420" alt="Corner (L)" style="display:block!important;" onload="console.log('L-shape image loaded successfully')" onerror="console.log('Failed to load L-shape image, using fallback'); this.src='https://via.placeholder.com/280x280/e8f4f8/0077c8?text=L+Shape';">
          <p>Corner (L)</p>
        </div>
        <div class="shape-card" data-id="U">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/ushape_png.png?v=1752528420" alt="U Shape" style="display:block!important;" onload="console.log('U-shape image loaded successfully')" onerror="console.log('Failed to load U-shape image, using fallback'); this.src='https://via.placeholder.com/280x280/e8f4f8/0077c8?text=U+Shape';">
          <p>U Shape</p>
        </div>
        <div class="shape-card" data-id="BOX">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/enclosed_png.png?v=1752528421" alt="Enclosed" style="display:block!important;" onload="console.log('Enclosed image loaded successfully')" onerror="console.log('Failed to load Enclosed image, using fallback'); this.src='https://via.placeholder.com/280x280/e8f4f8/0077c8?text=Enclosed';">
          <p>Enclosed</p>
        </div>
      </div>
      <div id="customTile" style="display:flex;justify-content:center;align-items:center;margin-top:2rem;width:100%;">
        <div class="shape-card" data-id="CUSTOM" style="width:240px;flex-shrink:0;">
          <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/custom.png?v=1752805887" alt="Custom" style="display:block!important;" onload="console.log('Custom image loaded successfully')" onerror="console.log('Failed to load Custom image, using fallback'); this.src='https://via.placeholder.com/280x280/e8f4f8/0077c8?text=Custom';">
          <p>Custom</p>
        </div>
      </div>
      <button id="shapeNext" disabled>NEXT</button>
    </div>

    <!-- CALCULATOR -->
    <div id="calcCard" class="card" style="display:none">
      <button id="backBtn">← Back</button>

      <div id="shapeDiagram" style="text-align:center;margin:1rem 0"></div>

      <!-- SVG Drawing Pad (shows only for Custom shape) -->
      <div id="svgDrawSection" style="display:none; margin:2rem -4rem; padding:1.5rem; border:2px dashed #0077c8; border-radius:12px; background:linear-gradient(135deg, #f8fbff 0%, #e8f4ff 100%); max-width:none; width:calc(100% + 8rem);">
        <h3 style="margin:0 0 1rem 0; text-align:center; color:#0077c8; font-size:1.4rem;">✏️ Draw Your Custom Shape</h3>
        <p style="text-align:center; color:#666; margin-bottom:1.5rem; font-size:0.95rem;">Click points to create your fence layout. Each line represents a side of your fence.</p>
        <div style="display:flex; justify-content:center; margin-bottom:1rem;">
          <svg id="svgGridPad" width="95%" height="500" style="border:2px solid #0077c8; background:#fff; border-radius:8px; cursor:crosshair; max-width:1400px;"></svg>
        </div>
        <div id="svgSideLengths" style="margin:1rem 0; font-weight:600; text-align:center; color:#0077c8; min-height:2rem;"></div>
        <div style="display:flex; justify-content:center; flex-wrap:wrap; gap:0.3rem; margin-top:0.8rem;">
          <button id="svgUndoBtn" type="button" style="background:#17a2b8; color:white; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.85rem; display:flex; align-items:center; justify-content:center;" disabled>↶</button>
          <button id="svgRedoBtn" type="button" style="background:#17a2b8; color:white; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.85rem; display:flex; align-items:center; justify-content:center;" disabled>↷</button>
          <button id="svgDoneBtn" type="button" style="background:#28a745; color:white; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.75rem; display:flex; align-items:center; justify-content:center;">✓</button>
          <button id="svgClearBtn" type="button" style="background:#dc3545; color:white; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.75rem; display:flex; align-items:center; justify-content:center;">✕</button>
          <button id="svgEditBtn" type="button" style="background:#ffc107; color:#333; padding:0.5rem; width:2.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.75rem; display:flex; align-items:center; justify-content:center; display:none;">✎</button>
          <button id="svgSubmitLayoutBtn" type="button" style="background:#0077c8; color:white; padding:0.4rem 1.2rem; height:2.2rem; border-radius:4px; font-weight:600; border:none; cursor:pointer; font-size:0.85rem; display:flex; align-items:center; justify-content:center;">Apply Side Lengths</button>
        </div>
      </div>

      <div id="sideInputs"></div>

      <div class="grid">
        <div>
          <label>Fence type</label>
          <select id="fenceType">
            <!-- Updated gap range labels to reflect new allowed gaps: 10–26 mm for balustrade, 10–50 mm for pool fences -->
            <option value="balustrade">Balustrade </option>
            <option value="pool">Pool Fence </option>
          </select>
        </div>

        <div>
          <label>Fixing type</label>
          <select id="fixingType">
            <option value="">– select –</option>
            <option value="Concrete">Concrete</option>
            <option value="Steel">Steel</option>
            <option value="Timber (Coach Screw)">Timber (Coach Screw)</option>
            <option value="Timber (Bolt Through)">Timber (Bolt Through)</option>
          </select>
        </div>

        <div>
          <label>Wind zone</label>
          <select id="windZone">
            <option value="L">L</option>
<option value="M">M</option>
            <option value="H">H</option>
<option value="VH">VH</option>
<option value="EH">EH</option>
          </select>
        </div>

        <div>
          <label>Glass height (mm)</label>
          <select id="glassHt">
            <option>1000</option>
            <option>1050</option>
            <option>1100</option>
            <option>1150</option>
            <option>1200</option>
            <option>1250</option>
            <option>1300</option>
            <option>1350</option>
            <option>1400</option>
            <option>1450</option>
            <option>1500</option>
          </select>
        </div>

        <div>
<label>Glass thickness</label><select id="glassThk"></select>
</div>
        <div>
<label>Handrail</label><select id="handrailType"></select>
</div>
        <div>
          <label>Hardware finish</label>
          <select id="finishType">
            <option value="MILL" selected>Mill</option>
            <option value="PC">Powdercoated (specify colour)</option>
          </select>
          <input type="text" id="powdercoatColor" placeholder="Enter colour (e.g. Matt Black, White, etc.)" style="display:none;margin-top:0.5rem;">
        </div>
        <input id="cornerCount" type="hidden">

        <!-- mixed‐panel checkbox -->
        <div id="allowMixedContainer" style="grid-column:1/2">
          <label>
            <input type="checkbox" id="allowMixed">
            Allow mixed panel sizes (±200 mm)
          </label>
        </div>
        <!-- Glass Mode selector and Gap selector: inserted to allow glass-first mode -->
        <div style="display:flex; flex-wrap:wrap; gap:1rem; align-items:flex-end; grid-column:1/-1;">
          <div style="min-width:140px;">
            <label>Glass Mode</label>
            <select id="glassType" style="width:100%; min-width:120px;">
              <option value="standard" selected>Standard</option>
              <option value="stock">Stock Sizes</option>
            </select>
          </div>
          <div id="gapSelectContainer" style="min-width:140px;">
            <label>Gap size (mm)</label>
            <select id="gapSize" style="width:100%; min-width:120px;"></select>
          </div>
        </div>
        <div>
          <label>
            <input type="checkbox" id="limit4Discs">
            Prefer Smaller Panels
          </label>
        </div>
      </div>

      <!-- DISC HEAD TYPE PICKER (not used for SD100) -->
      <!-- Hidden for SD100: only one head type available. -->
      <div id="discHeadPicker" style="display:none;"></div>

      <button id="calcBtn">Calculate compliant layout</button>
      <div id="output"></div>

      <div id="orderList" style="display:none">
        <table class="order-table">
          <thead>
            <tr><th colspan="3">Order List</th></tr>
            <tr>
<th>Description</th>
<th>Code</th>
<th>Qty</th>
</tr>
          </thead>
          <tbody></tbody>
        </table>
        <button id="emailBtn">Email Order List</button>
        <div class="flexBtns">
          <button id="pdfBtn">Download Plan (PDF)</button>
          <button id="orderPdfBtn">Download Glass Order (PDF)</button>
          <button id="view3dBtn">View 3D Plan</button>
        </div>
      </div>
    </div>

    <!-- Drawing UI removed - now integrated into calculator form -->

    <div id="visual"></div>
  </div>

  <script>
  // ─── Helpers & State ───────────────────────────────────────
  const $ = id=>document.getElementById(id),
        PX = .2,
        MAR= 120,  // Increased margin for arrow space
        rnd= x=>+x.toFixed(1),
        letters='ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  // Initialize layouts and sideLens as empty arrays
  // sideLens holds lengths for each side, which will be populated when shapes are selected
  let layouts = [], sideLens = [];
  // Panel width stepping: 50mm by default for stock sizes; set to 0 for continuous widths in Glass Mode
  let PANEL_STEP = 50;

  // ─── Shape picker ─────────────────────────────────────────
const shapes=[
  {id:'INLINE',label:'Inline',sides:1,corners:0,img:'https://cdn.shopify.com/s/files/1/0663/2738/0132/files/inline_png.png?v=1752528420'},
  {id:'L',     label:'Corner (L)',sides:2,corners:1,img:'https://cdn.shopify.com/s/files/1/0663/2738/0132/files/lshaped_png.png?v=1752528420'},
  {id:'U',     label:'U Shape',   sides:3,corners:2,img:'https://cdn.shopify.com/s/files/1/0663/2738/0132/files/ushape_png.png?v=1752528420'},
  {id:'BOX',   label:'Enclosed',  sides:4,corners:4,img:'https://cdn.shopify.com/s/files/1/0663/2738/0132/files/enclosed_png.png?v=1752528421'}
];
// Images now loaded directly in HTML - commenting out dynamic generation
/*
shapes.forEach(s=>
  $('shapeGrid').insertAdjacentHTML('beforeend',`
    <div class="shape-card" data-id="${s.id}">
      <img src="${s.img}" alt="${s.label}" onerror="console.log('Failed to load image: ${s.img}')">
      <p>${s.label}</p>
    </div>`)
);

// Add custom tile
$('customTile').innerHTML = `
  <div class="shape-card" data-id="CUSTOM" style="max-width:350px;">
    <img src="https://cdn.shopify.com/s/files/1/0663/2738/0132/files/custom.png?v=1752805887" alt="Custom" onerror="console.log('Failed to load custom image')">
    <p>Custom</p>
  </div>
`;
*/

  let curShape=null;
  let selectedDiscHead = null;

// Handle clicks on both main grid and custom tile
function handleShapeClick(e) {
  console.log('Shape click event triggered', e.target);
  const c=e.target.closest('.shape-card');
  console.log('Found shape card:', c);
  if(!c) return;
  
  console.log('Shape selected:', c.dataset.id);
  document.querySelectorAll('.shape-card').forEach(n=>n.classList.remove('selected'));
  c.classList.add('selected');
  
  if(c.dataset.id === 'CUSTOM') {
    curShape = {id:'CUSTOM',label:'Custom',sides:1,corners:0};
    $('shapeNext').disabled=false;
    
    // Show SVG drawing section immediately for Custom shape
    const svgDrawSection = document.getElementById('svgDrawSection');
    if(svgDrawSection) {
      svgDrawSection.style.display = 'block';
    }
    
    // Initialize drawing variables
    if(typeof points !== 'undefined') {
      points = [];
      ghost = null;
      currentDrawingPoint = null;
      currentDrawingPointIndex = null;
      isDrawingMode = true;
      if(typeof drawFreehandPad === 'function') drawFreehandPad();
      if(typeof updateFreehandSideLengths === 'function') updateFreehandSideLengths();
      if(typeof updateUI === 'function') updateUI();
    }
    return;
  }
  
  // Hide SVG drawing section for non-custom shapes
  const svgDrawSection = document.getElementById('svgDrawSection');
  if(svgDrawSection) svgDrawSection.style.display = 'none';
  
  curShape=shapes.find(o=>o.id===c.dataset.id);
  console.log('Current shape set to:', curShape);
  $('shapeNext').disabled=false;
  
  // Redraw the shape diagram when a shape is selected
  if(typeof drawMini === 'function') {
    drawMini();
  }
}

// Robust event handler attachment
const shapeGrid = $('shapeGrid');
const customTile = $('customTile');

if (shapeGrid) {
  console.log('Attaching event handler to shapeGrid');
  shapeGrid.onclick = handleShapeClick;
} else {
  console.error('shapeGrid element not found!');
}

if (customTile) {
  console.log('Attaching event handler to customTile');
  customTile.onclick = handleShapeClick;
} else {
  console.error('customTile element not found!');
}

// ─── Hardware finish handlers ────────────────────────────
$('finishType').onchange = function() {
  const powdercoatInput = $('powdercoatColor');
  if (this.value === 'PC') {
    powdercoatInput.style.display = 'block';
  } else {
    powdercoatInput.style.display = 'none';
  }
};

// ─── Disc head selection handlers ────────────────────────
document.querySelectorAll('.disc-head-card').forEach(card => {
  card.onclick = function() {
    // Remove selected class from all cards
    document.querySelectorAll('.disc-head-card').forEach(c => c.classList.remove('selected'));
    // Add selected class to clicked card
    this.classList.add('selected');
    // Store selection
    selectedDiscHead = this.getAttribute('data-head');
  };
  
  card.onkeydown = function(e) {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      this.click();
    }
  };
});

// Select first disc head by default
if (document.querySelector('.disc-head-card')) {
  document.querySelector('.disc-head-card').click();
}

  // ─── Navigation ───────────────────────────────────────────
  const shapeNextBtn = document.getElementById('shapeNext');
  
  if(shapeNextBtn) {
    shapeNextBtn.onclick = function() {
      // Use direct DOM manipulation
      document.getElementById('shapePicker').style.display = 'none';
      const calcCard = document.getElementById('calcCard');
      if(calcCard) {
        calcCard.style.display = 'block';
        calcCard.style.visibility = 'visible';
      }
      
      // Handle Custom shape differently - show SVG pad, don't build standard inputs
      if(curShape && curShape.id === 'CUSTOM') {
        // Hide shape diagram for custom shapes (not needed)
        const shapeDiagram = document.getElementById('shapeDiagram');
        if(shapeDiagram) {
          shapeDiagram.style.display = 'none';
        }
        
        // Clear any existing side inputs 
        const sideInputsDiv = document.getElementById('sideInputs');
        if(sideInputsDiv) sideInputsDiv.innerHTML = '';
        
        // Show SVG drawing section
        const svgDrawSection = document.getElementById('svgDrawSection');
        if(svgDrawSection) {
          svgDrawSection.style.display = 'block';
        }
        
        // Initialize drawing variables
        if(typeof points !== 'undefined') {
          points = [];
          ghost = null;
          currentDrawingPoint = null;
          currentDrawingPointIndex = null;
          isDrawingMode = true;
          if(typeof drawFreehandPad === 'function') drawFreehandPad();
          if(typeof updateFreehandSideLengths === 'function') updateFreehandSideLengths();
          if(typeof updateUI === 'function') updateUI();
        }
        
        // Populate dropdowns
        if(typeof refreshSelectors === 'function') {
          refreshSelectors();
        }
      } else {
        // Standard shapes - hide SVG pad and build normal inputs
        const svgDrawSection = document.getElementById('svgDrawSection');
        if(svgDrawSection) svgDrawSection.style.display = 'none';
        if(typeof buildSideInputs === 'function') buildSideInputs(); 
        if(typeof drawMini === 'function') drawMini(); 
        if(typeof refreshSelectors === 'function') refreshSelectors();
      }
      
      const cornerCount = document.getElementById('cornerCount');
      if(cornerCount) cornerCount.value = curShape ? (curShape.corners || 0) : 0;
    };
  }
  $('backBtn').onclick=()=>{
    // Hide calculation interface and show shape picker
    $('calcCard').style.display='none';
    $('shapePicker').style.display='';
    $('opusLogo').style.display='none';
    
    // Reset title back to generic
    $('mainTitle').innerHTML = `
      Opus Hardware – Glass Designer
      <span class="beta-badge">Beta</span>
    `;
    
    // Reset shape selection
    document.querySelectorAll('.shape-card').forEach(c=>c.classList.remove('selected'));
    $('shapeNext').disabled=true;
    
    // Clear all visual displays and prevent redrawing
    $('visual').innerHTML=''; 
    $('output').innerHTML=''; 
    $('orderList').style.display='none';
    $('sideInputs').innerHTML='';
    
    // Force clear visual area and prevent any lingering content
    const visualElement = $('visual');
    if(visualElement) {
      visualElement.innerHTML = '';
      visualElement.style.display = '';
      // Remove any child elements that might have been added
      while(visualElement.firstChild) {
        visualElement.removeChild(visualElement.firstChild);
      }
    }
    
    // Reset all main form inputs to default values
    $('fenceType').value = 'balustrade';
    $('fixingType').value = 'standoff';
    $('windZone').value = 'N1';
    $('glassHt').value = '1000';
    $('glassThk').value = '12';
    $('handrailType').value = 'none';
    $('finishType').value = 'mill';
    $('powdercoatColor').value = '';
    $('powdercoatColor').style.display = 'none';
    $('cornerCount').value = '';
    $('extraPackers').value = '';
    
    // Reset checkboxes to default state
    $('allowMixed').checked = true;
    $('limit4Discs').checked = false;
    
    // Clear all dynamic spanLen inputs (side lengths)
    document.querySelectorAll('.spanLen').forEach(input => {
      input.value = '';
    });
    
    // Reset any gate-related controls that might exist
    document.querySelectorAll('input[type="checkbox"][class*="gate"]').forEach(checkbox => {
      checkbox.checked = false;
    });
    document.querySelectorAll('input[type="range"][class*="gate"]').forEach(slider => {
      slider.value = slider.min || 0;
    });
    
    // Clear any dynamically generated content areas
    $('shapeDiagram').innerHTML = '';
    
    // Hide SVG drawing section if visible
    const svgSection = $('svgDrawSection');
    if(svgSection) svgSection.style.display = 'none';
    
    // Clear SVG pad if it exists
    const svgPad = $('svgGridPad');
    if(svgPad) svgPad.innerHTML = '';
    
    // Clear side lengths display
    const sideLengths = $('svgSideLengths');
    if(sideLengths) sideLengths.innerHTML = '';
    
    // Reset disc head picker selections
    document.querySelectorAll('#discHeadPicker .disc-option').forEach(option => {
      option.classList.remove('selected');
    });
    
    // Reset global variables and clear all data
    curShape = null;
    if(typeof layouts !== 'undefined') layouts = [];
    if(typeof sideLens !== 'undefined') sideLens = [];
    if(typeof layout !== 'undefined') layout = null;
    if(typeof spans !== 'undefined') spans = [];
    if(typeof points !== 'undefined') points = [];
    if(typeof finishedShapes !== 'undefined') finishedShapes = [];
    
    // Clear any cached layout data
    if(typeof currentLayout !== 'undefined') currentLayout = null;
    if(typeof calculatedLayouts !== 'undefined') calculatedLayouts = [];
    
    // Refresh selectors to reset dependent options
    if(typeof refreshSelectors === 'function') refreshSelectors();
    
    // Ensure visual area stays clear by preventing any automatic redraws
    setTimeout(() => {
      if($('visual')) $('visual').innerHTML = '';
    }, 100);
  };

  // ─── Side inputs & mini ───────────────────────────────────
  function buildSideInputs(){
      document.addEventListener('focusin', () => drawMini());
document.addEventListener('focusout', () => drawMini());
    $('sideInputs').innerHTML='<div class="grid">'+
      [...Array(curShape.sides).keys()].map(i=>`
        <div>
          <label>Side ${letters[i]} length (mm)</label>
          <input type="number" class="spanLen" data-i="${i}" min="500">
          <div style="margin-top:0.5rem;">
            <label style="display:flex;align-items:center;gap:0.5rem;font-size:0.9rem;color:#666;">
              <input type="checkbox" class="gateRequired" data-i="${i}" style="margin:0;">
              Gate required? (890mm + clearances)
            </label>
          </div>
        </div>`).join('')+
    '</div>';
    document.querySelectorAll('.spanLen').forEach(inp=>{
      inp.onfocus=()=>highlight(+inp.dataset.i);
      inp.onblur =()=>highlight(null);
    });
    
    // Gate checkbox event handlers
    document.querySelectorAll('.gateRequired').forEach(checkbox => {
      checkbox.onchange = () => {
        const sideIndex = checkbox.dataset.i;
        const positionControls = document.querySelector(`.gatePositionControls[data-i="${sideIndex}"]`);
        
        if (checkbox.checked) {
          positionControls.style.display = 'block';
          // Initialize gate position if not set
          if (!checkbox.dataset.gatePosition) {
            checkbox.dataset.gatePosition = 'middle';
          }
        } else {
          positionControls.style.display = 'none';
        }
        
        console.log(`Gate ${checkbox.checked ? 'enabled' : 'disabled'} for side ${letters[checkbox.dataset.i]}`);
        drawMini(); // Refresh the mini preview
      };
    });

    // Gate position button handlers
    document.querySelectorAll('.gateLeft, .gateRight').forEach(button => {
      button.onclick = () => {
        const sideIndex = button.dataset.i;
        const checkbox = document.querySelector(`.gateRequired[data-i="${sideIndex}"]`);
        const display = document.querySelector(`.gatePositionDisplay[data-i="${sideIndex}"]`);
        
        if (!checkbox.checked) return;
        
        let currentPosition = checkbox.dataset.gatePosition || 'middle';
        
        if (button.classList.contains('gateLeft')) {
          // Move left
          if (currentPosition === 'right') currentPosition = 'middle';
          else if (currentPosition === 'middle') currentPosition = 'left';
        } else {
          // Move right  
          if (currentPosition === 'left') currentPosition = 'middle';
          else if (currentPosition === 'middle') currentPosition = 'right';
        }
        
        checkbox.dataset.gatePosition = currentPosition;
        display.textContent = currentPosition.charAt(0).toUpperCase() + currentPosition.slice(1);
        
        console.log(`Gate position for side ${letters[sideIndex]} changed to: ${currentPosition}`);
        drawMini(); // Refresh preview
      };
    });
  }
  function segMini(id){
    if(id==='INLINE') return [{d:'M20 10 v80',cx:20,cy:50}];
    if(id==='L')      return [{d:'M20 10 v80',cx:20,cy:50},{d:'M20 10 h80',cx:60,cy:10}];
    if(id==='U')      return [{d:'M20 10 v100',cx:20,cy:60},{d:'M20 10 h80',cx:60,cy:10},{d:'M100 10 v100',cx:100,cy:60}];
    return [
      {d:'M20 10 v60',cx:20,cy:40},
      {d:'M20 10 h80',cx:60,cy:10},
      {d:'M100 10 v60',cx:100,cy:40},
      {d:'M20 70 h80',cx:60,cy:70}
    ];
  }
function drawMini(){
  console.log('drawMini called, curShape:', curShape);
  
  // Check if we have a valid shape and the diagram container exists
  if (!curShape || !curShape.id || curShape.id === 'CUSTOM') {
    console.log('No valid shape or is CUSTOM, skipping diagram');
    return;
  }
  
  const diagramContainer = $('shapeDiagram');
  if (!diagramContainer) {
    console.log('shapeDiagram container not found');
    return;
  }
  
  const NS='http://www.w3.org/2000/svg',svg=document.createElementNS(NS,'svg');
  svg.setAttribute('width',240);svg.setAttribute('height',200);  // Increased height to fit U-shape
  const offsetX = 40, offsetY = 30;  // Reduced offsetY to fit better

  // Find which input is focused
  let selectedIdx = -1;
  document.querySelectorAll('.spanLen').forEach(inp => {
    if (document.activeElement === inp) selectedIdx = +inp.dataset.i;
  });

  function segMini(id){
    if(id==='INLINE') return [{d:`M${offsetX+20} ${offsetY+10} v120`,cx:offsetX+20,cy:offsetY+70}];
    if(id==='L')      return [
      {d:`M${offsetX+20} ${offsetY+10} h120`,cx:offsetX+80,cy:offsetY+10},     // A - Top
      {d:`M${offsetX+140} ${offsetY+10} v120`,cx:offsetX+140,cy:offsetY+70}    // B - Right
    ];
    if(id==='U')      return [
      {d:`M${offsetX+20} ${offsetY+10} h120`,cx:offsetX+80,cy:offsetY+10},     // A - Top
      {d:`M${offsetX+140} ${offsetY+10} v120`,cx:offsetX+140,cy:offsetY+70},   // B - Right
      {d:`M${offsetX+20} ${offsetY+130} h120`,cx:offsetX+80,cy:offsetY+130}    // C - Bottom
    ];
    // BOX shape - Clockwise: A(top), B(right), C(bottom), D(left)
    return [
      {d:`M${offsetX+20} ${offsetY+10} h120`,cx:offsetX+80,cy:offsetY+10},      // A - Top
      {d:`M${offsetX+140} ${offsetY+10} v120`,cx:offsetX+140,cy:offsetY+70},    // B - Right
      {d:`M${offsetX+20} ${offsetY+130} h120`,cx:offsetX+80,cy:offsetY+130},    // C - Bottom
      {d:`M${offsetX+20} ${offsetY+10} v120`,cx:offsetX+20,cy:offsetY+70}       // D - Left
    ];
  }
  segMini(curShape.id).forEach((s,i)=>{
    const p=document.createElementNS(NS,'path');
    p.id=`seg${i}`;p.setAttribute('d',s.d);
    p.setAttribute('stroke', i===selectedIdx ? '#000' : '#888');
    p.setAttribute('stroke-width',8);
    svg.appendChild(p);

    // Check if this side has a gate
    const gateCheckbox = document.querySelector(`.gateRequired[data-i="${i}"]`);
    const hasGate = gateCheckbox && gateCheckbox.checked;
    
    // Gate visualization removed to keep shape diagram clean
    // (Gate information is shown in the side length inputs and elevation views)

    const t=document.createElementNS(NS,'text');
    t.id=`lbl${i}`;t.textContent=letters[i];
    // Label positions for BOX shape - Clockwise: A(top), B(right), C(bottom), D(left)
    if(curShape.id==='BOX'){
      if(i===0){ t.setAttribute('x',s.cx);    t.setAttribute('y',s.cy-18); } // A - Top
      if(i===1){ t.setAttribute('x',s.cx+28); t.setAttribute('y',s.cy+24); } // B - Right
      if(i===2){ t.setAttribute('x',s.cx);    t.setAttribute('y',s.cy+25); } // C - Bottom (moved up)
      if(i===3){ t.setAttribute('x',s.cx-28); t.setAttribute('y',s.cy+24); } // D - Left
    }else if(curShape.id==='U'){
      if(i===0){ t.setAttribute('x',s.cx);    t.setAttribute('y',s.cy-18); } // A - Top
      if(i===1){ t.setAttribute('x',s.cx+28); t.setAttribute('y',s.cy+24); } // B - Right
      if(i===2){ t.setAttribute('x',s.cx);    t.setAttribute('y',s.cy+25); } // C - Bottom (moved up)
    }else if(curShape.id==='L' && i===0){
      t.setAttribute('x',s.cx); t.setAttribute('y',s.cy-18);              // A - Top
    }else if(curShape.id==='L' && i===1){
      t.setAttribute('x',s.cx+28); t.setAttribute('y',s.cy+24);           // B - Right
    }else{
      t.setAttribute('x',s.cx + (i===0?-28:i===1?48:0));
      t.setAttribute('y',s.cy + (i===0?24:i===1?-18:0));
    }
    t.setAttribute('font-size','22');
    t.setAttribute('text-anchor','middle');
    t.setAttribute('fill', i===selectedIdx ? '#000' : '#888');
    svg.appendChild(t);
  });
  console.log('Appending SVG to shapeDiagram container');
  $('shapeDiagram').innerHTML='';$('shapeDiagram').appendChild(svg);
  console.log('Shape diagram updated successfully');
}
function refreshSelectors() {
  $('fenceType').addEventListener('change', refreshSelectors);
  $('windZone').addEventListener('change', refreshSelectors);
  $('glassThk').addEventListener('change', refreshSelectors);
  $('fixingType').addEventListener('change', refreshSelectors);

  const pool = $('fenceType').value === 'pool',
        zone = $('windZone').value,
        thk = $('glassThk');

  // Save previous selection
  const prevThk = thk.value;

  // Set options - use 17.2 display for pool fence but keep 17.52 as value
  let opts;
  if (pool) {
    // Pool fences only allow 12mm and 15mm glass for Vista
    opts = [
      {value: '12', display: '12'},
      {value: '15', display: '15'}
    ];
  } else {
    // Balustrade: allow 12mm, 13.52mm, 15mm, and 17.52mm
    opts = [
      {value: '12', display: '12'},
      {value: '13.52', display: '13.52'},
      {value: '15', display: '15'},
      {value: '17.52', display: '17.52'}
    ];
  }
  
  thk.innerHTML = opts.map(o => `<option value="${o.value}">${o.display}</option>`).join('');

  // Restore previous selection if still available, otherwise default to first option
  const availableValues = opts.map(o => o.value);
  if (availableValues.includes(prevThk)) {
    thk.value = prevThk;
  } else {
    thk.value = availableValues[0];
  }

  // Handle pool fence thickness restrictions by wind zone
  if (pool) {
    // Extra-high zone: 12mm not permitted for pool fences
    if (zone === 'EH') {
      const opt12 = thk.querySelector('option[value="12"]');
      if (opt12) opt12.disabled = true;
      if (thk.value === '12') thk.value = '15';
    }
  } else {
    // Re-enable all options for balustrade
    opts.forEach(v => {
      const opt = thk.querySelector(`option[value="${v.value}"]`);
      if (opt) opt.disabled = false;
    });
  }

  // Determine allowed glass height range based on fence type and wind zone
  let minHt, maxHt;
  if (pool) {
    // Pool fence: heights start at 1200mm; Vista allows up to 1500mm (subject to PS1 filtering)
    minHt = 1200;
    maxHt = 1500;
  } else {
    // Balustrade: heights between 1000mm and 1400mm (subject to PS1 filtering)
    minHt = 1000;
    maxHt = 1400;
  }
  // Apply fixing type restriction: for balustrade only, Timber substrates have a maximum height of 1150 mm.
  // Do not apply this cap to pool fences, because pool heights start at 1200 mm and there are no heights
  // below 1150 mm available. Otherwise, the pool fence would have no valid height options.
  const fixType = $('fixingType').value;
  let finalMaxHt = maxHt;
  if (!pool && fixType && fixType.includes('Timber')) {
    finalMaxHt = Math.min(maxHt, 1150);
  }
  // Ensure finalMaxHt is not below minHt; if so, clamp to minHt (disabling all taller options)
  if (finalMaxHt < minHt) {
    finalMaxHt = minHt;
  }
  // Disable glass height options outside the allowed range
  document.querySelectorAll('#glassHt option').forEach(opt => {
    const h = +opt.textContent;
    if (h < minHt || h > finalMaxHt) {
      opt.disabled = true;
    } else {
      opt.disabled = false;
    }
  });
  // Adjust the current glass height selection if it is out of range
  const curHt = +$('glassHt').value;
  if (curHt < minHt || curHt > finalMaxHt || isNaN(curHt)) {
    // Set to the smallest available height in the allowed range
    $('glassHt').value = String(minHt);
  }

  // Further filter the height options based on PS1 structural limits.  
  // Hide heights that are not allowed for the selected glass thickness and wind zone.
  // Heights outside the PS1 mapping or marked >=999 are disallowed.  
  const currentZone = $('windZone').value;
  const currentThk = thk.value;
  document.querySelectorAll('#glassHt option').forEach(opt => {
    const hVal = opt.value || opt.textContent;
    const hNum = Number(hVal);
    let allowedByPS1 = false;
    if (pool) {
      // Pool fence: look up pool PS1 limits
      const pMapping = PS1 && PS1.pool && PS1.pool.internal ? PS1.pool.internal[currentThk] : undefined;
      const entry = pMapping ? (pMapping[hVal] || pMapping[String(hVal)] || pMapping[String(hNum)]) : undefined;
      if (entry && typeof entry[currentZone] !== 'undefined' && entry[currentZone] < 999) {
        allowedByPS1 = true;
      }
    } else {
      // Balustrade: look up balustrade PS1 limits
      const bMapping = PS1 && PS1.balustrade && PS1.balustrade.internal ? PS1.balustrade.internal[currentThk] : undefined;
      const entry = bMapping ? (bMapping[hVal] || bMapping[String(hVal)] || bMapping[String(hNum)]) : undefined;
      if (entry && typeof entry[currentZone] !== 'undefined' && entry[currentZone] < 999) {
        allowedByPS1 = true;
      }
    }
    // Hide or show the option based on PS1
    if (!allowedByPS1) {
      opt.disabled = true;
      opt.style.display = 'none';
    } else {
      // If it is within the min/max range (handled above) and allowed by PS1, ensure it's visible
      if (!opt.disabled) {
        opt.style.display = '';
      }
    }
  });
  // Ensure the selected height is valid; if not, pick the first allowed option
  const selectedOpt = $('glassHt').selectedOptions[0];
  if (selectedOpt && (selectedOpt.disabled || selectedOpt.style.display === 'none')) {
    const firstEnabled = Array.from(document.querySelectorAll('#glassHt option')).find(o => !o.disabled && o.style.display !== 'none');
    if (firstEnabled) {
      $('glassHt').value = firstEnabled.value;
    }
  }

  // Save current handrail selection
  const handrailSelect = $('handrailType');
  const prevHandrail = handrailSelect.value;

  const t = thk.value;
  const isToughened = t === '12' || t === '15'; // Toughened glass is 12mm and 15mm
  const isSentryGlass = t === '13.52' || t === '17.52'; // Sentry glass is 13.52mm and 17.52mm
  const hrOpts = [];
  
  if(!pool){
    if (isSentryGlass) {
      // For balustrade with sentry glass (13.52mm and 17.52mm), CANNOT have handrail
      hrOpts.push({v:'none',txt:'No'});
    } else if (isToughened) {
      // For balustrade with toughened glass (12mm, 15mm), MUST have handrail - no "No" option
      // Only add S25 if thickness is exactly 12 (not for 15mm)
      if(t === '12') hrOpts.push({v:'S25',txt:'S25'});
      // Add other handrails for toughened glass (12mm, 15mm)
      ['S40','AH40','R40'].forEach(v => hrOpts.push({v,txt:v}));
    } else {
      // For other glass types in balustrade, allow "No" option
      hrOpts.push({v:'none',txt:'No'});
    }
  } else {
    // For pool fence, "No" option is always available
    hrOpts.push({v:'none',txt:'No'});
  }
  handrailSelect.innerHTML = hrOpts.map(o => `<option value="${o.v}">${o.txt}</option>`).join('');

  // Restore previous selection if still available
  if ([...handrailSelect.options].some(opt => opt.value === prevHandrail)) {
    handrailSelect.value = prevHandrail;
  } else if (!pool && isToughened && prevHandrail === 'none') {
    // For toughened glass in balustrade, auto-select first available handrail if "none" was previously selected
    handrailSelect.value = hrOpts.length > 0 ? hrOpts[0].v : '';
  } else if (isSentryGlass) {
    // For sentry glass (13.52mm and 17.52mm), always force "none" selection
    handrailSelect.value = 'none';
  }
}
  // ─── PS‑1 + solver ────────────────────────────────────────
  const PS1 = {
    balustrade: {
      overhang: 250,
      internal: {
        '12': {
          '1000': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1050': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1100': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1150': { L: 999, M: 999, H: 999, VH: 999, EH: 999 } // Above 1100mm no longer permitted for balustrade
        },
        '13.52': {
          '1000': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1050': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1100': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1150': { L: 999, M: 999, H: 999, VH: 999, EH: 999 } // Above 1100mm no longer permitted for balustrade
        },
        '15': {
          '1000': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1050': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1100': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1150': { L: 999, M: 999, H: 999, VH: 999, EH: 999 }, // Above 1100mm no longer permitted for balustrade
          '1200': { L: 999, M: 999, H: 999, VH: 999, EH: 999 }, // Above 1100mm no longer permitted for balustrade
          '1250': { L: 999, M: 999, H: 999, VH: 999, EH: 999 }  // Above 1100mm no longer permitted for balustrade
        },
        '17.52': {
          '1000': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1050': { L: 425, M: 425, H: 425, VH: 425, EH: 425 },
          '1100': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1150': { L: 999, M: 999, H: 999, VH: 999, EH: 999 }, // Above 1100mm no longer permitted for balustrade
          '1200': { L: 999, M: 999, H: 999, VH: 999, EH: 999 }, // Above 1100mm no longer permitted for balustrade
          '1250': { L: 999, M: 999, H: 999, VH: 999, EH: 999 }  // Above 1100mm no longer permitted for balustrade
        }
      }
    },
    pool: {
      overhang: { '12': 500, '15': 500, '17.52': 500 },
      internal: {
        '12': {
          // Updated height allowances: 1200–1300mm for L, 1200–1250mm for M/H, 1200mm for VH/EH
          '1200': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1250': { L: 400, M: 400, H: 400, VH: 999, EH: 999 },
          '1300': { L: 400, M: 999, H: 999, VH: 999, EH: 999 },
          '1350': { L: 999, M: 999, H: 999, VH: 999, EH: 999 }
        },
        '15': {
          // Updated height allowances: 1200–1300mm for L, 1200–1250mm for M/H, 1200mm for VH/EH
          '1200': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1250': { L: 400, M: 400, H: 400, VH: 999, EH: 999 },
          '1300': { L: 400, M: 999, H: 999, VH: 999, EH: 999 },
          '1350': { L: 999, M: 999, H: 999, VH: 999, EH: 999 }
        },
        '17.52': {
          // Updated height allowances: 1200–1300mm for L, 1200–1250mm for M/H, 1200mm for VH/EH
          '1200': { L: 400, M: 400, H: 400, VH: 400, EH: 400 },
          '1250': { L: 400, M: 400, H: 400, VH: 999, EH: 999 },
          '1300': { L: 400, M: 999, H: 999, VH: 999, EH: 999 },
          '1350': { L: 999, M: 999, H: 999, VH: 999, EH: 999 }
        }
      }
    }
  };
  const sym = (run,min,max,maxP) => {
    let cnt=Math.ceil(run/maxP);
    while(cnt<600){
      let pw=Math.min(maxP,Math.floor(run/cnt/50)*50);
      while(pw>=200){
        const gap=(run-pw*cnt)/(cnt+1);
        if(gap>=min&&gap<=max) return {panelWidths:Array(cnt).fill(pw),gap,run};
        pw-=50;
      }
      cnt++;
    }
    return null;
  };
  const mix = (run,min,max,maxP) => {
    let cnt=Math.ceil(run/maxP);
    while(cnt<600){
      for(let A=maxP;A>=200;A-=50){
        for(let B=A;B>=A-200;B-=50){
          for(let k=1;k<cnt;k++){
            const tot=(cnt-k)*A+k*B,
                  gap=(run-tot)/(cnt+1);
            if(gap>=min&&gap<=max){
              return {panelWidths:[...Array(cnt-k).fill(A),...Array(k).fill(B)],gap,run};
            }
          }
        }
      }
      cnt++;
    }
    return null;
  };
  const groupPanels = a => {
    // Group identical panel widths and show counts; when using continuous widths (PANEL_STEP <= 0),
    // round widths to two decimal places for grouping to avoid many near-identical keys.
    const m = {};
    a.forEach(w => {
      // Determine the grouping key based on panel stepping
      const key = (PANEL_STEP <= 0 ? (Math.round(w * 100) / 100).toFixed(2) : String(w));
      m[key] = (m[key] || 0) + 1;
    });
    return Object.entries(m).map(([w, n]) => `${n}× @${w} mm`).join('<br>');
  };

  // Populate the gap size selector based on fence type (balustrade vs pool).
  function updateGapOptions() {
    const fenceEl = $('fenceType');
    const gapEl = $('gapSize');
    if (!fenceEl || !gapEl) return;
    const fenceVal = fenceEl.value;
    // Clear existing options
    gapEl.innerHTML = '';
    const minGap = 10;
    const maxGap = (fenceVal === 'pool') ? 50 : 26;
    for (let g = minGap; g <= maxGap; g++) {
      const opt = document.createElement('option');
      opt.value = g;
      opt.textContent = g;
      gapEl.appendChild(opt);
    }
    // Set default gap to 20 mm if within range
    if (20 >= minGap && 20 <= maxGap) gapEl.value = 20;
  }

  // Toggle visibility of gap size and mixed panel checkbox based on Glass Mode.
  function updateGlassModeUI() {
    const mode = $('glassType') ? $('glassType').value : 'standard';
    const gapContainer = $('gapSelectContainer');
    const allowMixedDiv = $('allowMixedContainer');
    if (!gapContainer || !allowMixedDiv) return;
    if (mode === 'standard') {
      gapContainer.style.display = '';
      allowMixedDiv.style.display = 'none';
      updateGapOptions();
    } else {
      gapContainer.style.display = 'none';
      allowMixedDiv.style.display = '';
    }
  }

  // ─── Calculate ─────────────────────────────────────────────
  $('calcBtn').onclick = function() {
    console.log('Calculate button clicked');
    
    const spans = [...document.querySelectorAll('.spanLen')].map(i => +i.value);
    console.log('Side lengths:', spans);
    
    if (spans.some(v => !v)) { 
      console.log('Missing side lengths');
      return alert('Enter every side length'); 
    }

    const fence = $('fenceType').value;
    const thk = $('glassThk').value;
    const ht = $('glassHt').value;
    const zone = $('windZone').value;
    const hr = $('handrailType').value;
    const fin = $('finishType').value;
    const fix = $('fixingType').value;
    // Determine glass mode and selected gap for dynamic behaviour
    const glassMode = $('glassType') ? $('glassType').value : 'standard';
    const selectedGap = $('gapSize') ? +$('gapSize').value : 20;
    // Panel stepping: 0 for continuous widths in Standard mode, 50mm for Stock mode
    PANEL_STEP = (glassMode === 'standard') ? 0 : 50;
    // In Standard mode, mixed panels are disabled; otherwise use checkbox value
    let allowMix = (glassMode === 'standard') ? false : $('allowMixed').checked;
    
    console.log('Calculation inputs:', {fence, thk, ht, zone, hr, fin, fix});
    
    if (!thk) {
      console.log('No glass thickness selected');
      return alert('Please select glass thickness');
    }
    if (!ht) {
      console.log('No glass height selected');
      return alert('Please select glass height');
    }
    if (!zone) {
      console.log('No wind zone selected');
      return alert('Please select wind zone');
    }
    if (!fix) {
      console.log('No fixing type selected');
      return alert('Please select fixing type (substrate)');
    }
    
    const pool = fence === 'pool';
    const isToughened = thk === '12' || thk === '15'; // Toughened glass is 12mm and 15mm
    const isSentryGlass = thk === '13.52' || thk === '17.52'; // Sentry glass is 13.52mm and 17.52mm
    console.log('Pool check:', pool, 'HR value:', hr, 'Toughened glass:', isToughened, 'Sentry glass:', isSentryGlass);
    
    // Handrail validation rules:
    // - Balustrade with Sentry glass (13.52mm, 17.52mm): CANNOT have handrail
    // - Balustrade with Toughened glass (12mm, 15mm): MUST have handrail
    // - Pool fence: Optional handrail
    
    // Check if Sentry glass has a handrail selected (not allowed for balustrade)
    if (!pool && isSentryGlass && hr && hr !== 'none') {
      console.log('Handrail not allowed - Sentry glass detected');
      return alert('⚠️ Warning: Handrails are not permitted with Sentry glass (13.52mm or 17.52mm) in balustrade applications.\n\nPlease select "No" handrail or choose a different glass thickness.');
    }
    
    // Check if toughened glass requires handrail for balustrade
    if (!pool && isToughened && (!hr || hr === 'none')) {
      console.log('Handrail required - Toughened glass detected');
      return alert(`⚠️ Warning: Handrail selection is required for balustrade with toughened glass (12mm or 15mm thickness).\n\nToughened glass requires additional structural support. Please select an appropriate handrail option.`);
    }

    console.log('All inputs validated, continuing with calculation...');

    // Handle powdercoat color
    let finishSuffix = fin;
    let powdercoatColor = '';
    if (fin === 'PC') {
      powdercoatColor = $('powdercoatColor').value.trim();
      if (powdercoatColor) {
        finishSuffix = `PC-${powdercoatColor.replace(/\s+/g, '')}`;
      }
    }

    // Validate PS1 data (still used to ensure glass thickness / height / zone combination is allowed)
    if (!pool) {
      if (PS1.balustrade.internal[thk] && PS1.balustrade.internal[thk][ht]) {
        const ps1Spacing = PS1.balustrade.internal[thk][ht][zone];
        console.log(`PS1 lookup: ${thk}mm, ${ht}mm, ${zone} = ${ps1Spacing}mm spacing (unused for channel)`);
        // If PS1 indicates a non-suitable combination (≥999), alert user
        if (ps1Spacing >= 999) {
          return alert(`⚠️ Warning: ${thk}mm glass at ${ht}mm height in ${zone} wind zone is not suitable for balustrade applications.\n\nThis combination exceeds PS1 structural limits. Please adjust your selections:\n• Try a different glass thickness\n• Try a different glass height\n• Try a lower wind zone if applicable`);
        }
      } else {
        console.error(`PS1 data missing for: ${thk}mm, ${ht}mm, ${zone}`);
        const availableHeights = [];
        if (PS1.balustrade.internal[thk]) {
          Object.keys(PS1.balustrade.internal[thk]).forEach(height => {
            if (height !== ht) availableHeights.push(height + 'mm');
          });
        }
        const heightList = availableHeights.length > 0
          ? availableHeights.join(', ')
          : '950mm, 1000mm, 1050mm (check PS1 data)';
        return alert(`⚠️ Warning: No PS1 data available for ${thk}mm glass at ${ht}mm height.\n\nThis combination is not within PS1 specification. Please change the glass height to achieve compliance.\n\nRecommended heights for ${thk}mm glass: ${heightList}`);
      }
    }

    // Channel system: define maximum panel width and gap limits based on handrail type and fence
    let cap;
    if (!hr || hr === 'none') {
      cap = 2000;
    } else if (hr === 'S25') {
      cap = 1700;
    } else if (hr === 'S40' || hr === 'AH40' || hr === 'R40') {
      cap = 1900;
    } else {
      cap = 2000;
    }
    // If the "Prefer Smaller Panels" option is selected, limit the maximum panel
    // width to 1500 mm. This reduces large panels when customers prefer smaller
    // segments. We enforce this after determining the default cap based on
    // handrail type.
    if ($('limit4Discs') && $('limit4Discs').checked) {
      cap = Math.min(cap, 1500);
    }
    // Gap ranges: In Standard (glass-first) mode, use a fixed selected gap; otherwise default ranges based on fence type
    let gMin, gMax;
    if (glassMode === 'standard') {
      gMin = selectedGap;
      gMax = selectedGap;
    } else {
      gMin = 10;
      gMax = pool ? 50 : 26;
    }

    // Initialise arrays for layouts and panels, and counters for totals, rails and gaskets
    layouts = [];
    sideLens = spans;
    let total = 0, panels = [], rails = 0, gasket = 0, handrailMeters = 0;

    // Channel-based layout solvers
    function channelSym(run, minGap, maxGap, maxPanel) {
      let cnt = Math.ceil(run / maxPanel);
      while (cnt < 600) {
        // In continuous mode with a fixed gap, derive the panel width directly
        if ((PANEL_STEP <= 0 || PANEL_STEP < 1) && Math.abs(minGap - maxGap) < 1e-9) {
          const desiredGap = minGap;
          let pw = (run - desiredGap * (cnt + 1)) / cnt;
          // If derived panel exceeds maximum, cap it
          if (pw > maxPanel) pw = maxPanel;
          if (pw >= 200) {
            const gap = (run - pw * cnt) / (cnt + 1);
            if (gap >= minGap && gap <= maxGap) {
              return { panelWidths: Array(cnt).fill(pw), gap, run };
            }
          }
          cnt++;
          continue;
        }
        // Otherwise, iterate panel widths in decrements of PANEL_STEP (or 50mm fallback)
        const step = (PANEL_STEP > 0 ? PANEL_STEP : 50);
        let pw = Math.min(maxPanel, Math.floor(run / cnt / step) * step);
        while (pw >= 200) {
          const gap = (run - pw * cnt) / (cnt + 1);
          if (gap >= minGap && gap <= maxGap) {
            return { panelWidths: Array(cnt).fill(pw), gap, run };
          }
          pw -= step;
        }
        cnt++;
      }
      return null;
    }
    function channelMix(run, minGap, maxGap, maxPanel) {
      let cnt = Math.ceil(run / maxPanel);
      const step = (PANEL_STEP > 0 ? PANEL_STEP : 50);
      while (cnt < 600) {
        for (let A = maxPanel; A >= 200; A -= step) {
          for (let B = A; B >= A - 200; B -= step) {
            for (let k = 1; k < cnt; k++) {
              const tot = (cnt - k) * A + k * B;
              const gap = (run - tot) / (cnt + 1);
              if (gap >= minGap && gap <= maxGap) {
                return { panelWidths: [...Array(cnt - k).fill(A), ...Array(k).fill(B)], gap, run };
              }
            }
          }
        }
        cnt++;
      }
      return null;
    }
    function findBestChannelLayout(originalLen, minGap, maxGap, maxPanel, allowMixed) {
      // Use mixed solver only when mixing is allowed and a discrete panel step is set
      const useMix = allowMixed && PANEL_STEP > 0;
      let bestLayout = useMix
        ? (channelMix(originalLen, minGap, maxGap, maxPanel) || channelSym(originalLen, minGap, maxGap, maxPanel))
        : (channelSym(originalLen, minGap, maxGap, maxPanel) || channelMix(originalLen, minGap, maxGap, maxPanel));
      if (bestLayout) {
        bestLayout.adjustedLength = originalLen;
        bestLayout.adjustment = 0;
        return bestLayout;
      }
      // Nudge ±1–5 mm to find a layout
      for (let nudge = 1; nudge <= 5; nudge++) {
        for (let direction of [-1, 1]) {
          const adjustedLen = originalLen + (direction * nudge);
          if (adjustedLen < 200) continue;
          const layout = useMix
            ? (channelMix(adjustedLen, minGap, maxGap, maxPanel) || channelSym(adjustedLen, minGap, maxGap, maxPanel))
            : (channelSym(adjustedLen, minGap, maxGap, maxPanel) || channelMix(adjustedLen, minGap, maxGap, maxPanel));
          if (layout) {
            if (!bestLayout || layout.panelWidths.length < bestLayout.panelWidths.length) {
              bestLayout = layout;
              bestLayout.adjustedLength = adjustedLen;
              bestLayout.adjustment = direction * nudge;
            }
          }
        }
        if (bestLayout) break;
      }
      return bestLayout;
    }
    function findGateAdjustedChannelLayout(originalLen, minGap, maxGap, maxPanel, allowMixed) {
      // When a gate is present, there is one fewer gap than panels, so adjust gap calculation
      const gateSym = (run, min, max, maxP) => {
        let cnt = Math.ceil(run / maxP);
        while (cnt < 600) {
          // For continuous widths with fixed gap, compute panel size directly (gate removes one gap)
          if ((PANEL_STEP <= 0 || PANEL_STEP < 1) && Math.abs(min - max) < 1e-9) {
            const desiredGap = min;
            let pw = (run - desiredGap * cnt) / cnt;
            if (pw > maxP) pw = maxP;
            if (pw >= 200) {
              const gap = (run - pw * cnt) / cnt;
              if (gap >= min && gap <= max) return { panelWidths: Array(cnt).fill(pw), gap, run };
            }
            cnt++;
            continue;
          }
          const step = (PANEL_STEP > 0 ? PANEL_STEP : 50);
          let pw = Math.min(maxP, Math.floor(run / cnt / step) * step);
          while (pw >= 200) {
            const gap = (run - pw * cnt) / cnt;
            if (gap >= min && gap <= max) return { panelWidths: Array(cnt).fill(pw), gap, run };
            pw -= step;
          }
          cnt++;
        }
        return null;
      };
      const gateMix = (run, min, max, maxP) => {
        let cnt = Math.ceil(run / maxP);
        const step = (PANEL_STEP > 0 ? PANEL_STEP : 50);
        while (cnt < 600) {
          for (let A = maxP; A >= 200; A -= step) {
            for (let B = A; B >= A - 200; B -= step) {
              for (let k = 1; k < cnt; k++) {
                const tot = (cnt - k) * A + k * B;
                const gap = (run - tot) / cnt;
                if (gap >= min && gap <= max) {
                  return { panelWidths: [...Array(cnt - k).fill(A), ...Array(k).fill(B)], gap, run };
                }
              }
            }
          }
          cnt++;
        }
        return null;
      };
      // Use mixed solver only when mixing is allowed and step > 0
      const useMix = allowMixed && PANEL_STEP > 0;
      let bestLayout = useMix
        ? (gateMix(originalLen, minGap, maxGap, maxPanel) || gateSym(originalLen, minGap, maxGap, maxPanel))
        : (gateSym(originalLen, minGap, maxGap, maxPanel) || gateMix(originalLen, minGap, maxGap, maxPanel));
      if (bestLayout) {
        bestLayout.adjustedLength = originalLen;
        bestLayout.adjustment = 0;
        return bestLayout;
      }
      // Try nudging ±1–5 mm to find a solution
      for (let nudge = 1; nudge <= 5; nudge++) {
        for (let direction of [-1, 1]) {
          const adjustedLen = originalLen + (direction * nudge);
          if (adjustedLen < 200) continue;
          const layout = useMix
            ? (gateMix(adjustedLen, minGap, maxGap, maxPanel) || gateSym(adjustedLen, minGap, maxGap, maxPanel))
            : (gateSym(adjustedLen, minGap, maxGap, maxPanel) || gateMix(adjustedLen, minGap, maxGap, maxPanel));
          if (layout) {
            if (!bestLayout || layout.panelWidths.length < bestLayout.panelWidths.length) {
              bestLayout = layout;
              bestLayout.adjustedLength = adjustedLen;
              bestLayout.adjustment = direction * nudge;
            }
          }
        }
        if (bestLayout) break;
      }
      return bestLayout;
    }

    function sd50Sym(run, minGap, maxGap, maxPanel) {
      let cnt = Math.ceil(run / maxPanel);
      while (cnt < 600) {
        let pw = Math.min(maxPanel, Math.floor(run / cnt / 25) * 25);
        while (pw >= 200) {
          let discs = Math.max(2, Math.ceil((pw - 2 * edge) / MAX_SPACING) + 1);
          if (discs > MAX_DISCS_PER_PANEL) {
            pw = edge * 2 + (MAX_DISCS_PER_PANEL - 1) * MAX_SPACING;
            discs = MAX_DISCS_PER_PANEL;
          }
          let maxPanelWidth = edge * 2 + (discs - 1) * MAX_SPACING;
          if (pw > maxPanelWidth) pw = maxPanelWidth;
          const gap = (run - pw * cnt) / (cnt + 1);
          if (gap >= minGap && gap <= maxGap) {
            return { panelWidths: Array(cnt).fill(pw), gap, run };
          }
          pw -= 50;
        }
        cnt++;
      }
      return null;
    }
    function sd50Mix(run, minGap, maxGap, maxPanel) {
      let cnt = Math.ceil(run / maxPanel);
      while (cnt < 600) {
        for (let A = maxPanel; A >= 200; A -= 25) {
          for (let B = A; B >= A - 200; B -= 25) {
            for (let k = 1; k < cnt; k++) {
              let discsA = Math.max(2, Math.ceil((A - 2 * edge) / MAX_SPACING) + 1);
              let discsB = Math.max(2, Math.ceil((B - 2 * edge) / MAX_SPACING) + 1);
              if (discsA > MAX_DISCS_PER_PANEL) A = edge * 2 + (MAX_DISCS_PER_PANEL - 1) * MAX_SPACING;
              if (discsB > MAX_DISCS_PER_PANEL) B = edge * 2 + (MAX_DISCS_PER_PANEL - 1) * MAX_SPACING;
              const tot = (cnt - k) * A + k * B;
              const gap = (run - tot) / (cnt + 1);
              if (gap >= minGap && gap <= maxGap) {
                return { panelWidths: [...Array(cnt - k).fill(A), ...Array(k).fill(B)], gap, run };
              }
            }
          }
        }
        cnt++;
      }
      return null;
    }

    // Special layout finder for gate scenarios - accounts for reduced gap count
    function findGateAdjustedLayout(originalLen, minGap, maxGap, maxPanel, allowMixed) {
      // Create modified versions of sym and mix that account for fewer gaps
      const gateAdjustedSym = (run, min, max, maxP) => {
        let cnt = Math.ceil(run / maxP);
        while (cnt < 600) {
          let pw = Math.min(maxP, Math.floor(run / cnt / 50) * 50);
          while (pw >= 200) {
            // Modified gap calculation: cnt gaps instead of cnt+1 (gate replaces one gap)
            const gap = (run - pw * cnt) / cnt;
            if (gap >= min && gap <= max) return { panelWidths: Array(cnt).fill(pw), gap, run };
            pw -= 50;
          }
          cnt++;
        }
        return null;
      };

      const gateAdjustedMix = (run, min, max, maxP) => {
        let cnt = Math.ceil(run / maxP);
        while (cnt < 600) {
          for (let A = maxP; A >= 200; A -= 50) {
            for (let B = A; B >= A - 200; B -= 50) {
              for (let k = 1; k < cnt; k++) {
                const tot = (cnt - k) * A + k * B;
                // Modified gap calculation: cnt gaps instead of cnt+1
                const gap = (run - tot) / cnt;
                if (gap >= min && gap <= max) {
                  return { panelWidths: [...Array(cnt - k).fill(A), ...Array(k).fill(B)], gap, run };
                }
              }
            }
          }
          cnt++;
        }
        return null;
      };

      // First try the exact length
      let bestLayout = allowMixed
        ? (gateAdjustedMix(originalLen, minGap, maxGap, maxPanel) || gateAdjustedSym(originalLen, minGap, maxGap, maxPanel))
        : (gateAdjustedSym(originalLen, minGap, maxGap, maxPanel) || gateAdjustedMix(originalLen, minGap, maxGap, maxPanel));
      
      if (bestLayout) {
        bestLayout.adjustedLength = originalLen;
        bestLayout.adjustment = 0;
        return bestLayout;
      }

      // Try nudging ±1mm to ±5mm
      for (let nudge = 1; nudge <= 5; nudge++) {
        for (let direction of [-1, 1]) {
          const adjustedLen = originalLen + (direction * nudge);
          if (adjustedLen < 200) continue;
          
          const layout = allowMixed
            ? (gateAdjustedMix(adjustedLen, minGap, maxGap, maxPanel) || gateAdjustedSym(adjustedLen, minGap, maxGap, maxPanel))
            : (gateAdjustedSym(adjustedLen, minGap, maxGap, maxPanel) || gateAdjustedMix(adjustedLen, minGap, maxGap, maxPanel));
          
          if (layout) {
            if (!bestLayout || layout.panelWidths.length < bestLayout.panelWidths.length) {
              bestLayout = layout;
              bestLayout.adjustedLength = adjustedLen;
              bestLayout.adjustment = direction * nudge;
            }
          }
        }
        if (bestLayout) break;
      }
      
      return bestLayout;
    }

    // Enhanced solver with run length nudging for "unlucky" lengths
    function findBestLayout(originalLen, minGap, maxGap, maxPanel, allowMixed) {
      // First try the exact length
      let bestLayout = allowMixed
        ? (sd50Mix(originalLen, minGap, maxGap, maxPanel) || sd50Sym(originalLen, minGap, maxGap, maxPanel))
        : (sd50Sym(originalLen, minGap, maxGap, maxPanel) || sd50Mix(originalLen, minGap, maxGap, maxPanel));
      
      if (bestLayout) {
        bestLayout.adjustedLength = originalLen;
        bestLayout.adjustment = 0;
        return bestLayout;
      }

      // Try nudging ±1mm to ±5mm to find a better solution
      for (let nudge = 1; nudge <= 5; nudge++) {
        // Try shorter length first (fewer panels preferred)
        for (let direction of [-1, 1]) {
          const adjustedLen = originalLen + (direction * nudge);
          if (adjustedLen < 200) continue; // Don't go below minimum reasonable length
          
          const layout = allowMixed
            ? (sd50Mix(adjustedLen, minGap, maxGap, maxPanel) || sd50Sym(adjustedLen, minGap, maxGap, maxPanel))
            : (sd50Sym(adjustedLen, minGap, maxGap, maxPanel) || sd50Mix(adjustedLen, minGap, maxGap, maxPanel));
          
          if (layout) {
            // Prefer solutions with fewer panels (wider panels)
            if (!bestLayout || layout.panelWidths.length < bestLayout.panelWidths.length) {
              bestLayout = layout;
              bestLayout.adjustedLength = adjustedLen;
              bestLayout.adjustment = direction * nudge;
            }
          }
        }
        
        // If we found a solution with this nudge amount, return it
        if (bestLayout) break;
      }
      
      return bestLayout;
    }

    // Validate hinge panel size for gates
    function validateHingePanelSize(layout, gateSegment, gatePosition) {
      if (!layout || !gateSegment) return layout;
      
      console.log(`Validating hinge panel for gate at position: ${gatePosition}, hingeOnLeft: ${gateSegment.hingeOnLeft}`);
      
      // Allowed hinge panel sizes: 800-1500mm in 100mm increments
      const allowedHingeSizes = [800, 900, 1000, 1100, 1200, 1300, 1400, 1500];
      
      // Check if uniform panels is enabled - if so, skip hinge panel validation
      const uniformCheckbox = document.getElementById('uniformPanels');
      if (uniformCheckbox && uniformCheckbox.checked) {
        console.log('Uniform panels enabled - skipping hinge panel validation');
        return layout; // Allow uniform override
      }
      
      // Calculate gate panel index
      let gatePanelIndex;
      if (gateSegment.panelIndex !== undefined) {
        gatePanelIndex = gateSegment.panelIndex;
      } else {
        // Legacy support for position-based system
        const totalPanels = layout.panelWidths.length;
        
        if (gatePosition === 'left') {
          gatePanelIndex = Math.floor(totalPanels * 0.25); // 25% from left
        } else if (gatePosition === 'right') {
          gatePanelIndex = Math.floor(totalPanels * 0.75); // 75% from left  
        } else { // middle
          gatePanelIndex = Math.floor(totalPanels / 2); // 50% from left
        }
        
        // Update the gate segment with the calculated index for consistency
        gateSegment.panelIndex = gatePanelIndex;
      }
      
      // Determine hinge panel index based on gate position and hinge orientation
      const hingeOnLeft = gateSegment.hingeOnLeft !== undefined ? gateSegment.hingeOnLeft : false;
      let hingePanelIndex;
      
      if (hingeOnLeft) {
        // Hinge is on left side of gate, so hinge panel is the panel at the gate position
        // (since gate appears AFTER the panel in the drawing loop)
        hingePanelIndex = gatePanelIndex;
      } else {
        // Hinge is on right side of gate, so hinge panel is the next panel after gate
        hingePanelIndex = gatePanelIndex + 1;
      }
      
      console.log(`Gate panel index: ${gatePanelIndex}, Hinge panel index: ${hingePanelIndex}, Total panels: ${layout.panelWidths.length}`);
      
      // Store the hinge panel index in the gate segment for later reference
      gateSegment.hingePanelIndex = hingePanelIndex;
      
      // Check if hinge panel index is valid
      if (hingePanelIndex < 0 || hingePanelIndex >= layout.panelWidths.length) {
        console.warn(`Hinge panel index ${hingePanelIndex} is out of bounds. Gate at panel ${gatePanelIndex}, total panels: ${layout.panelWidths.length}`);
        return layout; // Can't validate if panel doesn't exist, but don't fail
      }
      
      const hingePanelSize = layout.panelWidths[hingePanelIndex];
      console.log(`Current hinge panel size: ${hingePanelSize}mm`);
      
      // Check if hinge panel size is valid
      if (!allowedHingeSizes.includes(hingePanelSize)) {
        // Try to find the closest allowed size
        const closest = allowedHingeSizes.reduce((prev, curr) => 
          Math.abs(curr - hingePanelSize) < Math.abs(prev - hingePanelSize) ? curr : prev
        );
        
        // If the difference is reasonable (within 200mm), adjust the panel
        if (Math.abs(closest - hingePanelSize) <= 200) {
          layout.panelWidths[hingePanelIndex] = closest;
          console.log(`Adjusted hinge panel (index ${hingePanelIndex}) from ${hingePanelSize}mm to ${closest}mm for gate compatibility. Gate at panel ${gatePanelIndex}, hinge on ${hingeOnLeft ? 'left' : 'right'}`);
        } else {
          // Panel size is too far from allowed range - but don't fail the whole operation
          console.warn(`Hinge panel size ${hingePanelSize}mm is not compatible with gate requirements. Allowed sizes: ${allowedHingeSizes.join(', ')}mm - continuing anyway`);
        }
      } else {
        console.log(`Hinge panel size ${hingePanelSize}mm (index ${hingePanelIndex}) is valid for gate requirements. Gate at panel ${gatePanelIndex}, hinge on ${hingeOnLeft ? 'left' : 'right'}`);
      }
      
      return layout; // Always return the layout, even if we couldn't optimize it
    }

    for (let i = 0; i < spans.length; i++) {
      const len = spans[i];
      let effectiveLength = len;
      let gateSegment = null;
      
      // Check if this side has a gate
      let gateRequired = false;
      if (curShape && curShape.id === 'CUSTOM') {
        // For custom shapes, check the custom gate checkboxes
        const customGateCheckbox = document.querySelector(`.customGateRequired[data-side="${i}"]`);
        gateRequired = customGateCheckbox && customGateCheckbox.checked;
        
        // Get custom gate position
        if (gateRequired && customGateCheckbox) {
          const customGatePosition = customGateCheckbox.dataset.gatePosition || 'middle';
          
          gateSegment = {
            type: 'gate',
            leafWidth: 890,
            hingeGap: 5,
            latchGap: 10,
            totalWidth: 905,
            sideIndex: i,
            position: customGatePosition,
            hingeOnLeft: false  // Default: hinge on right, latch on left
          };
        }
      } else {
        // For standard shapes, check the standard gate checkboxes
        const gateCheckbox = document.querySelector(`.gateRequired[data-i="${i}"]`);
        gateRequired = gateCheckbox && gateCheckbox.checked;
      }
      
      if (gateRequired) {
        // Gate dimensions: 890mm leaf + 5mm hinge clearance + 10mm latch clearance = 905mm total
        const GATE_TOTAL_WIDTH = 905;
        
        // Calculate effective length for fence portion
        effectiveLength = len - GATE_TOTAL_WIDTH;
        
        if (effectiveLength < 200) {
          return alert(`Side ${String.fromCharCode(65 + i)} is too short for a gate. Minimum required: ${GATE_TOTAL_WIDTH + 200}mm (gate + min panel width)`);
        }
        
        // Get gate position from UI
        const gateCheckbox = document.querySelector(`.gateRequired[data-i="${i}"]`);
        const gatePosition = gateCheckbox ? (gateCheckbox.dataset.gatePosition || 'middle') : 'middle';
        
        gateSegment = {
          type: 'gate',
          leafWidth: 890,
          hingeGap: 5,
          latchGap: 10,
          totalWidth: GATE_TOTAL_WIDTH,
          sideIndex: i,
          position: gatePosition,
          hingeOnLeft: false  // Default: hinge on right, latch on left
        };
        
        console.log(`Side ${String.fromCharCode(65 + i)}: Gate added (${GATE_TOTAL_WIDTH}mm) at ${gatePosition} position, fence portion: ${effectiveLength}mm`);
      }

      // For gate scenarios, we need to find a layout and validate hinge panel
      let lay;
      if (gateRequired) {
        // Try to find a layout where gap formula accounts for fewer gaps
        lay = findGateAdjustedChannelLayout(effectiveLength, gMin, gMax, cap, allowMix);
        
        // Validate hinge panel size for gate compatibility
        if (lay && gateSegment) {
          const gatePosition = gateSegment.position || 'middle';
          lay = validateHingePanelSize(lay, gateSegment, gatePosition);
          
          if (!lay) {
            // If validation failed, try different nudging amounts or panel arrangements
            console.log(`Hinge panel validation failed, trying alternative layouts...`);
            
            // Try nudging in different directions to find a valid hinge panel size
            for (let nudge = 1; nudge <= 10; nudge++) {
              for (let direction of [-1, 1]) {
                const adjustedLen = effectiveLength + (direction * nudge);
                if (adjustedLen < 200) continue;
                
                const altLayout = findGateAdjustedChannelLayout(adjustedLen, gMin, gMax, cap, allowMix);
                if (altLayout) {
                  const validatedLayout = validateHingePanelSize(altLayout, gateSegment, gatePosition);
                  if (validatedLayout) {
                    validatedLayout.adjustment = direction * nudge;
                    validatedLayout.adjustedLength = adjustedLen;
                    lay = validatedLayout;
                    console.log(`Found valid hinge panel layout with ${direction * nudge}mm adjustment`);
                    break;
                  }
                }
              }
              if (lay) break;
            }
          }
        }
      } else {
        lay = findBestChannelLayout(effectiveLength, gMin, gMax, cap, allowMix);
      }
      
      if (!lay) {
        const errorMsg = gateRequired 
          ? `No compliant layout found for side ${String.fromCharCode(65 + i)} with gate. Check that hinge panel can be 800-1500mm (100mm increments) or enable uniform panels to override.`
          : `No compliant layout found even with ±5mm adjustment for side ${String.fromCharCode(65 + i)}`;
        return alert(errorMsg);
      }
      
      // Show adjustment info if length was nudged
      if (lay.adjustment !== 0) {
        console.log(`Run length ${effectiveLength}mm adjusted by ${lay.adjustment > 0 ? '+' : ''}${lay.adjustment}mm to ${lay.adjustedLength}mm for better panel layout`);
      }
      
      if (gateSegment) {
        lay.gateSegment = gateSegment;
        lay.originalLength = len;
      }
      
      layouts.push(lay);
      panels.push(...lay.panelWidths);
      total += lay.adjustedLength; // Use adjusted length for calculations
      
      // Debug: Log panel layout for each side
      console.log(`Side ${String.fromCharCode(65 + i)} (${len}mm): Panel widths = [${lay.panelWidths.join(', ')}], Gap = ${lay.gap}mm`);
      if (i === 2) { // Side C specific debug
        console.log(`Side C DEBUG: Original length=${len}, Effective length=${effectiveLength}, Adjusted length=${lay.adjustedLength}, Gate=${gateRequired}`);
      }
      
      // For channel systems, discs are not used; rails and gaskets are calculated after all sides are processed.
    }

    // summary table for channel system
    // Group panel sizes into "n× @width mm"
    const panelSummary = groupPanels(panels);
    // Calculate channel lengths required (each kit is 4800mm)
    const channelLengthsNeeded = Math.ceil(total / 4800);
    $('output').innerHTML=`
      <table class="results-table">
        <tr><th>Total run</th><td>${total} mm</td></tr>
        <tr><th>Panels</th><td>${panelSummary}</td></tr>
        <tr><th>Channel lengths</th><td>${channelLengthsNeeded} × 4.8 m</td></tr>
        <tr><th>Max panel width</th><td>${cap} mm</td></tr>
        <tr><th>Gap range</th><td>${gMin}–${gMax} mm</td></tr>
      </table>`;

    // order list
    const rows = [];
    // Compute rails, gasket and handrail length now that all sides have been processed
    if (hr !== 'none') {
      rails = Math.ceil(total / 5800);
      gasket = Math.ceil(total / 1000);
      handrailMeters = +(total / 1000).toFixed(1);
    }
    // Calculate channel lengths needed (each kit is 4.8m)
    const channelLensNeededOrder = Math.ceil(total / 4800);
    // Build channel kit code based on glass thickness and fixing type
    // Vista channel kit uses a single code regardless of glass thickness
    let kitBase = 'VC48KIT';
    let kitSuffix = '';
    if (fix === 'Concrete') kitSuffix = 'C';
    else if (fix === 'Steel') kitSuffix = 'S';
    else if (fix === 'Timber (Bolt Through)') kitSuffix = 'T';
    else if (fix === 'Timber (Coach Screw)') kitSuffix = 'L';
    const kitCode = kitBase + (kitSuffix ? '-' + kitSuffix : '');
    rows.push([kitCode, channelLensNeededOrder]);
    if(hr!=='none'){
      // For powdercoated items, use base codes and add separate PC charges
      const baseCode = hr;
      const needsPowdercoat = fin === 'PC';
      // Vista finish options: Mill or Powdercoat. S40, R40 and S25 rails do not come
      // in a mill finish, so they always use the stainless suffix '-SS'. Only the AH40
      // rail offers a mill finish option, which uses '-MILL' for the mill finish
      // and '-SS' otherwise.  Determine the rail suffix accordingly.
      let railSuf = '';
      if (hr === 'AH40') {
        railSuf = (fin === 'MILL') ? '-MILL' : '-SS';
      } else {
        // S25, S40 and R40 rails are only available in stainless finish
        railSuf = '-SS';
      }
      
      // Main handrail
      rows.push([baseCode + railSuf, rails]);
      
      if(gasket){
        const gc={'S25':'S25GR','S40':'S40GR1','AH40':'AHGR1','R40':'R40GR1'}[hr];
        rows.push([gc,gasket]);
      }
      
      // Joiners - use dynamic corner detection for custom shapes
      if (curShape && curShape.id === 'CUSTOM') {
        // Get detected corners and add appropriate joiners
        const corners = detectCornersAndJoiners();
        let ninetyDegreeCount = 0;
        let adjustableCount = 0;
        
        corners.forEach(corner => {
          if (corner.isNinetyDegree) {
            ninetyDegreeCount++;
          } else {
            adjustableCount++;
          }
        });
        
        // Add 90 degree corner joiners
        if (ninetyDegreeCount > 0) {
          if (hr === 'AH40') {
            rows.push(['AHJ90', ninetyDegreeCount]);
          } else {
            // Joiner suffix: S25, S40 and R40 joiners are only available in stainless finish.  
            // The finish code should always be '-SS' regardless of mill or powdercoat.
            const joinerSuf = '-SS';
            rows.push([baseCode + 'J90' + joinerSuf, ninetyDegreeCount]);
          }
        }
        
        // Add adjustable horizontal joiners
        if (adjustableCount > 0) {
          if (hr === 'AH40') {
            rows.push(['AHAHJ', adjustableCount]);
          } else {
            const joinerSuf = '-SS';
            rows.push([baseCode + 'HAJ' + joinerSuf, adjustableCount]);
          }
        }
        
        // Always add straight joiners for connecting segments
        if (hr === 'AH40') {
          rows.push(['AHJ180', Math.ceil(rails/2)]);
        } else {
          const joinerSuf = '-SS';
          rows.push([baseCode + 'J180' + joinerSuf, Math.ceil(rails/2)]);
        }
      } else {
        // Original logic for standard shapes
        if (hr === 'AH40') {
          // AH40 uses special joiner codes that don't get powdercoated
          rows.push(['AHJ180', Math.ceil(rails/2)]);
          const cj={'INLINE':0,'L':1,'U':2,'BOX':4}[curShape.id];
          if(cj) rows.push(['AHJ90', cj]);
        } else {
          // S40, S25, R40 get finish suffixes and can be powdercoated
          const joinerSuf = '-SS';
          rows.push([baseCode + 'J180' + joinerSuf, Math.ceil(rails/2)]);
          const cj={'INLINE':0,'L':1,'U':2,'BOX':4}[curShape.id];
          if(cj) rows.push([baseCode + 'J90' + joinerSuf, cj]);
        }
      }
      
      // Wall attachments
      let needW=!(curShape.id==='BOX'&&fence!=='balustrade');
      if(needW){
        if(hr==='S40'||hr==='S25'){
          // S40 and S25 wall attachments only come in stainless finish
          const walSuf = '-SS';
          rows.push([baseCode + 'WAL' + walSuf, 1], [baseCode + 'WAR' + walSuf, 1]);
        } else if(hr==='R40'){
          // R40 wall attachments only come in stainless finish
          const waSuf = '-SS';
          rows.push(['R40WA' + waSuf, 2]);
        } else if(hr==='AH40'){
          // AH40 wall brackets are available only in stainless finish for Vista
          const wbSuf = '-SS';
          rows.push(['AHWB' + wbSuf, 2]);
        }
      }
      
      // Add powdercoat charges if needed
      if(needsPowdercoat) {
        const colorSuffix = powdercoatColor ? ` (${powdercoatColor})` : '';
        
        // PC-BRACKET for joiners and wall attachments (AH40 joiners don't get powdercoated)
        let bracketQty = 0;
        if (hr !== 'AH40') {
          bracketQty = Math.ceil(rails/2); // J180 qty
          
          if (curShape && curShape.id === 'CUSTOM') {
            // For custom shapes, count detected corners
            const corners = detectCornersAndJoiners();
            corners.forEach(corner => {
              bracketQty += 1; // Each corner needs powdercoating
            });
          } else {
            // Original logic for standard shapes
            const cj={'INLINE':0,'L':1,'U':2,'BOX':4}[curShape.id];
            if(cj) bracketQty += cj; // J90 qty
          }
        }
        
        if(needW) {
          if(hr==='S40'||hr==='S25') bracketQty += 2; // WAL + WAR
          else if(hr==='R40') bracketQty += 2; // R40WA qty
          else if(hr==='AH40') bracketQty += 2; // AHWB qty
        }
        if (bracketQty > 0) {
          rows.push([`PC-BRACKET${colorSuffix}`, bracketQty]);
        }
        
        // PC-PERM for channel covers and handrail: covers = 2 × 4.8m per channel kit + handrail length
        const channelLens = Math.ceil(total / 4800);
        const pcPermMeters = +(channelLens * 2 * 4.8 + handrailMeters).toFixed(1);
        rows.push([`PC-PERM${colorSuffix}`, pcPermMeters]);
      }
    }

    // Count gates for handrail endcaps (process before gate hardware)
    let totalGates = 0;
    layouts.forEach((layout) => {
      if (layout.gateSegment) {
        totalGates++;
      }
    });

    // Add handrail endcaps for gates (2 per gate) - above gate hardware in order
    if (totalGates > 0 && hr !== 'none') {
      const endcapQty = totalGates * 2; // 2 endcaps per gate
      
      // Determine endcap codes based on handrail type
      let endcapCode = '';
      const needsPowdercoat = fin === 'PC';
      
      if (hr === 'S25') {
        endcapCode = needsPowdercoat ? 'S25EC-SS' : `S25EC-${fin}`;
      } else if (hr === 'S40') {
        endcapCode = needsPowdercoat ? 'S40EC-SS' : `S40EC-${fin}`;
      } else if (hr === 'AH40') {
        // AH40 endcaps use AHEC code, available in SS and BK only
        endcapCode = needsPowdercoat ? 'AHEC-SS' : (fin === 'SS' ? 'AHEC-SS' : 'AHEC-BK');
      } else if (hr === 'R40') {
        endcapCode = needsPowdercoat ? 'R40EC-SS' : `R40EC-${fin}`;
      }
      
      if (endcapCode) {
        rows.push([endcapCode, endcapQty]);
        console.log(`Added ${endcapQty} handrail endcaps (${endcapCode}) for ${totalGates} gates`);
        
        // Add powdercoat charge for endcaps if needed
        if (needsPowdercoat) {
          const colorSuffix = powdercoatColor ? ` (${powdercoatColor})` : '';
          rows.push([`PC-ENDCAP${colorSuffix}`, endcapQty]);
        }
      }
    }

    // Add extra packers if specified
    

    // Add gate components for each side that has a gate
    layouts.forEach((layout, i) => {
      if (layout.gateSegment) {
        console.log(`Adding gate components for Side ${String.fromCharCode(65 + i)}`);
        
        // Gate hardware - same for both pool and balustrade
        rows.push(['ASC180', 1]); // 1 pair of hinges per gate
        rows.push(['PL180GG', 1]); // 1 latch per gate
      }
    });

    const tb=document.querySelector('.order-table tbody');
    tb.innerHTML='';
    
    // Function to get description for item codes
    function getItemDescription(code) {
      // Vista channel kit (single kit regardless of glass thickness)
      if (code.startsWith('VC48KIT')) return 'Vista Channel Kit (4.8m)';
      // Lugano channel kits (legacy)
      if (code.startsWith('LC48KIT1')) return 'Lugano Channel Kit for 12/15mm Glass (4.8m)';
      if (code.startsWith('LC48KIT2')) return 'Lugano Channel Kit for 13.52/17.52mm Glass (4.8m)';
      // Disc types - SD100 uses single standoff discs.  Map codes accordingly.
      if (code.includes('ASD100-SH')) return 'Adjustable Screw Head Standoff Disc';
      if (code.includes('ASD100-FH')) return 'Adjustable Flat Head Standoff Disc';
      if (code.includes('ASD100-BH')) return 'Adjustable Bevelled Head Standoff Disc';
      if (code.includes('ASD100')) return 'Adjustable Standoff Disc';
      if (code.includes('SD100')) return '100 mm Standoff Disc';
      
      // Powdercoating
      if (code.startsWith('PC1-DISC')) return 'Disc Powdercoating';
      if (code.startsWith('PC1-RAIL')) return 'Rail Powdercoating';

      // Channel powdercoating
      if (code.startsWith('PC-BRACKET')) return 'Powdercoat Brackets/Joiners';
      if (code.startsWith('PC-PERM')) return 'Powdercoat Channel & Handrail (per metre)';
      
      // Fixing components - SD100 uses M12 hardware
      if (code === 'TR12-180') return 'Threaded Rod M12 x 180mm';
      if (code === 'TR12-50') return 'Threaded Rod M12 x 50mm';
      if (code === 'TR12-150') return 'Threaded Rod M12 x 150mm';
      if (code === 'HN-M12') return 'Hex Nut M12';
      if (code === 'FW-M1224') return 'Flat Washer M12';
      if (code === 'LS12-140') return 'Lag Screw M12 x 140mm';
      
      // Handrails - handle base codes and codes with suffixes
      if (code.startsWith('S25') && !code.includes('GR') && !code.includes('J') && !code.includes('WAL') && !code.includes('WAR')) {
        return 'S25 Square Handrail (25x25mm)';
      }
      if (code.startsWith('S40') && !code.includes('GR') && !code.includes('J')) {
        return 'S40 Square Handrail (40x40mm)';
      }
      if (code.startsWith('AH40') && !code.includes('GR') && !code.includes('J')) {
        return 'AH40 Aluminium Handrail';
      }
      if (code.startsWith('R40') && !code.includes('GR') && !code.includes('J')) {
        return 'R40 Round Handrail (40mm dia)';
      }
      
      // Gaskets - exact matches first
      if (code === 'S25GR') return 'S25 Handrail Gasket';
      if (code === 'S40GR1') return 'S40 Handrail Gasket';
      if (code === 'AHGR1') return 'AH40 Aluminium Handrail Gasket';
      if (code === 'R40GR1') return 'R40 Handrail Gasket';
      if (code.includes('GR-GATE')) return 'Gate Handrail Gasket';
      if (code.endsWith('-GATE') && code.includes('GR')) return 'Gate Handrail Gasket';
      
      // Joiners - comprehensive matching for all handrail types
      if (code === 'AHJ180') return 'AH40 Aluminium Handrail Straight Joiner (180°)';
      if (code === 'AHJ90') return 'AH40 Aluminium Handrail 90° Corner Joiner';
      if (code === 'AHAHJ') return 'AH40 Aluminium Handrail Adjustable Horizontal Joiner';
      
      // S40 joiners
      if (code.startsWith('S40J180')) return 'S40 Straight Joiner (180°)';
      if (code.startsWith('S40J90')) return 'S40 90° Corner Joiner';
      if (code.startsWith('S40HAJ')) return 'S40 Adjustable Horizontal Joiner';
      
      // S25 joiners  
      if (code.startsWith('S25J180')) return 'S25 Straight Joiner (180°)';
      if (code.startsWith('S25J90')) return 'S25 90° Corner Joiner';
      if (code.startsWith('S25HAJ')) return 'S25 Adjustable Horizontal Joiner';
      
      // R40 joiners
      if (code.startsWith('R40J180')) return 'R40 Straight Joiner (180°)';
      if (code.startsWith('R40J90')) return 'R40 90° Corner Joiner';
      if (code.startsWith('R40HAJ')) return 'R40 Adjustable Horizontal Joiner';
      
      // Generic joiner fallbacks (should catch any remaining patterns)
      if (code.includes('J180')) return 'Straight Joiner (180°)';
      if (code.includes('J90')) return '90° Corner Joiner';
      if (code.includes('HAJ')) return 'Adjustable Horizontal Joiner';
      if (code.includes('CJ')) return 'Corner Joiner';
      
      // Wall attachment components
      if (code.startsWith('S40WAL')) return 'S40 Wall Attachment Left';
      if (code.startsWith('S40WAR')) return 'S40 Wall Attachment Right';
      if (code.startsWith('S25WAL')) return 'S25 Wall Attachment Left';
      if (code.startsWith('S25WAR')) return 'S25 Wall Attachment Right';
      if (code.startsWith('R40WA')) return 'R40 Wall Attachment';
      if (code.startsWith('AHWB')) return 'AH40 Aluminium Handrail Wall Bracket';
      
      // Generic wall attachment fallbacks
      if (code.includes('WAL')) return 'Wall Attachment Left';
      if (code.includes('WAR')) return 'Wall Attachment Right';
      if (code.includes('WA')) return 'Wall Attachment';
      if (code.includes('WB')) return 'Wall Bracket';
      
      // Extra packers
      if (code === 'FG100-08') return 'Fiber Gasket, 100mmDia x 0.8mm';
      
      // Gate hardware - with finish suffix handling
      if (code.startsWith('ASC180')) {
        let desc = 'Atlantic Soft Close Hinge G2G 180° (Pair)';
        if (code.endsWith('-SS')) desc += ' - Stainless Steel';
        else if (code.endsWith('-BK')) desc += ' - Black';
        else if (code.endsWith('-PS')) desc += ' - Powder Coated Stainless';
        return desc;
      }
      if (code.startsWith('PL180GG')) {
        let desc = 'Pool Gate Latch G2G 180°';
        if (code.endsWith('-SS')) desc += ' - Stainless Steel';
        else if (code.endsWith('-BK')) desc += ' - Black';
        else if (code.endsWith('-PS')) desc += ' - Powder Coated Stainless';
        return desc;
      }
      
      // Catch any remaining gate codes
      if (code.startsWith('GATE-')) return 'Gate Hardware Component';
      
      // Default fallback - but this should rarely be used now
      return 'Hardware Component';
    }
    
    rows.forEach(([c,q])=>{
      const description = getItemDescription(c);
      tb.insertAdjacentHTML('beforeend',`<tr><td>${description}</td><td>${c}</td><td>${q}</td></tr>`);
    });
    $('orderList').style.display='';
    drawRows();
  };

  // ─── Redraw single elevation (preserves scroll position) ───
  function redrawSingleElevation(sideIndex, lay) {
    const NS = 'http://www.w3.org/2000/svg';
    
    // Find the existing view element for this side
    const allViews = document.querySelectorAll('#visual .view');
    if (!allViews[sideIndex]) return;
    
    const viewElement = allViews[sideIndex];
    
    // Clear existing SVG
    viewElement.innerHTML = '';
    
    // Recreate the SVG for this specific side
    const gPx = lay.gap * PX;
    const actualLength = lay.gateSegment ? sideLens[sideIndex] : (lay.adjustedLength || sideLens[sideIndex]);
    const svgW = actualLength * PX + MAR * 2;
    const svgH = 140;
    const svg = document.createElementNS(NS, 'svg');
    svg.setAttribute('width', svgW);
    svg.setAttribute('viewBox', `0 0 ${svgW} ${svgH}`);

    let x = MAR;
    
    // Draw initial gap
    (() => {
      const r = document.createElementNS(NS, 'rect');
      r.setAttribute('x', x); r.setAttribute('y', 20);
      r.setAttribute('width', gPx); r.setAttribute('height', 100);
      r.setAttribute('fill', '#ddd');
      svg.appendChild(r);
      const t = document.createElementNS(NS, 'text');
      t.textContent = rnd(lay.gap);
      t.setAttribute('x', x + gPx / 2); t.setAttribute('y', 16);
      t.setAttribute('text-anchor', 'middle'); t.setAttribute('font-size', '12');
      t.setAttribute('font-weight', 'bold');
      t.setAttribute('fill', '#0077c8');
      svg.appendChild(t);
      x += gPx;
    })();

    // Draw panels and gates
    lay.panelWidths.forEach((pw, panelIndex) => {
      // Check if this panel position is where the gate should be placed
      let isGatePosition = false;
      let isHingePanelPosition = false;
      
      if (lay.gateSegment) {
        const gatePanelIndex = lay.gateSegment.panelIndex !== undefined 
          ? lay.gateSegment.panelIndex 
          : Math.floor(lay.panelWidths.length / 2);
        
        isGatePosition = (panelIndex === gatePanelIndex);
        
        // Check for wall-to-glass conditions
        const totalPanels = lay.panelWidths.length;
        const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
        const isWallToGlassHinge = (gatePanelIndex === 0 && hingeOnLeft); // Gate at start, hinge to wall
        const isWallToGlassLatch = (gatePanelIndex === totalPanels - 1 && !hingeOnLeft); // Gate at end, latch to wall
        
        // Use direct hinge panel index tracking if available, but skip for wall-to-glass hinge
        if (lay.gateSegment.hingePanelIndex !== undefined && !isWallToGlassHinge) {
          isHingePanelPosition = (panelIndex === lay.gateSegment.hingePanelIndex);
        } else if (!isWallToGlassHinge) {
          // Fallback to calculation for initial setup (but not for wall-to-glass)
          if (hingeOnLeft) {
            isHingePanelPosition = (panelIndex === gatePanelIndex);
          } else {
            isHingePanelPosition = (panelIndex === gatePanelIndex + 1);
          }
        }
        // If wall-to-glass hinge, no hinge panel is drawn
        
        if (panelIndex === 0 || panelIndex === gatePanelIndex || panelIndex === gatePanelIndex - 1 || panelIndex === gatePanelIndex + 1) {
          console.log(`Panel ${panelIndex}: Gate=${isGatePosition}, Hinge=${isHingePanelPosition}, GateIndex=${gatePanelIndex}, HingeIndex=${lay.gateSegment.hingePanelIndex}, WallHinge=${isWallToGlassHinge}, WallLatch=${isWallToGlassLatch}`);
        }
      }
      
      if (isHingePanelPosition) {
        // This is the hinge panel - draw it with special styling
        console.log(`Drawing HINGE PANEL at position ${panelIndex} with width ${pw}mm`);
        const w = pw * PX;
        const r = document.createElementNS(NS, 'rect');
        r.setAttribute('x', x); r.setAttribute('y', 20);
        r.setAttribute('width', w); r.setAttribute('height', 100);
        r.setAttribute('fill', '#d6f0ff'); // Light blue-tint for hinge panel
        r.setAttribute('stroke', '#333');
        r.setAttribute('stroke-width', '2');
        svg.appendChild(r);
        
        // Add "HINGE" label inside the rectangle (like the gate has "GATE")
        const hingeLabel = document.createElementNS(NS, 'text');
        hingeLabel.textContent = 'HINGE';
        hingeLabel.setAttribute('x', x + w / 2); hingeLabel.setAttribute('y', 75);
        hingeLabel.setAttribute('text-anchor', 'middle'); hingeLabel.setAttribute('font-size', '14');
        hingeLabel.setAttribute('font-weight', 'bold');
        hingeLabel.setAttribute('fill', '#0066cc'); // Blue text to match the blue theme
        svg.appendChild(hingeLabel);
        
        // Size label underneath (keep existing)
        const t = document.createElementNS(NS, 'text');
        // Display hinge panel width with rounding when continuous widths are used
        const hingeDisp = (PANEL_STEP <= 0 ? (Math.round(pw * 100) / 100).toFixed(2) : pw);
        t.textContent = `Hinge Panel ${hingeDisp}`;
        t.setAttribute('x', x + w / 2); t.setAttribute('y', 105);
        t.setAttribute('text-anchor', 'middle'); t.setAttribute('font-size', '12');
        t.setAttribute('font-weight', 'bold');
        t.setAttribute('fill', '#333');
        svg.appendChild(t);
        x += w;
        
        // Add gap after hinge panel - this becomes the 5mm hinge gap
        const gPx = 5 * PX; // Force 5mm gap for hinge
        const gapR = document.createElementNS(NS, 'rect');
        gapR.setAttribute('x', x); gapR.setAttribute('y', 20);
        gapR.setAttribute('width', gPx); gapR.setAttribute('height', 100);
        gapR.setAttribute('fill', '#ffff99'); gapR.setAttribute('stroke', '#666'); // Yellow for hinge gap
        svg.appendChild(gapR);
        const gapT = document.createElementNS(NS, 'text');
        gapT.textContent = '5mm H';
        gapT.setAttribute('x', x + gPx / 2); gapT.setAttribute('y', 75);
        gapT.setAttribute('text-anchor', 'middle'); gapT.setAttribute('font-size', '10');
        gapT.setAttribute('fill', '#666');
        svg.appendChild(gapT);
        x += gPx;
        
      } else if (isGatePosition) {
        // This is the gate position - draw the 890mm gate with wall-to-glass logic
        console.log(`Drawing GATE at position ${panelIndex}`);
        
        // Check for wall-to-glass conditions
        const totalPanels = lay.panelWidths.length;
        const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
        const isWallToGlassHinge = (panelIndex === 0 && hingeOnLeft); // Gate at start, hinge to wall
        const isWallToGlassLatch = (panelIndex === totalPanels - 1 && !hingeOnLeft); // Gate at end, latch to wall
        
        // Draw hinge gap before gate (if not wall-to-glass hinge)
        if (!isWallToGlassHinge) {
          const hingeGapW = 5 * PX; // Standard 5mm hinge gap
          const hingeGapR = document.createElementNS(NS, 'rect');
          hingeGapR.setAttribute('x', x); hingeGapR.setAttribute('y', 20);
          hingeGapR.setAttribute('width', hingeGapW); hingeGapR.setAttribute('height', 100);
          hingeGapR.setAttribute('fill', '#ffff99'); hingeGapR.setAttribute('stroke', '#666');
          svg.appendChild(hingeGapR);
          const hingeGapT = document.createElementNS(NS, 'text');
          hingeGapT.textContent = '5mm H';
          hingeGapT.setAttribute('x', x + hingeGapW / 2); hingeGapT.setAttribute('y', 75);
          hingeGapT.setAttribute('text-anchor', 'middle'); hingeGapT.setAttribute('font-size', '10');
          hingeGapT.setAttribute('fill', '#666');
          svg.appendChild(hingeGapT);
          x += hingeGapW;
        } else {
          // Wall-to-glass hinge: 7mm gap to wall
          const wallHingeGapW = 7 * PX;
          const wallHingeGapR = document.createElementNS(NS, 'rect');
          wallHingeGapR.setAttribute('x', x); wallHingeGapR.setAttribute('y', 20);
          wallHingeGapR.setAttribute('width', wallHingeGapW); wallHingeGapR.setAttribute('height', 100);
          wallHingeGapR.setAttribute('fill', '#ff9999'); wallHingeGapR.setAttribute('stroke', '#666'); // Different color for wall gap
          svg.appendChild(wallHingeGapR);
          const wallHingeGapT = document.createElementNS(NS, 'text');
          wallHingeGapT.textContent = '7mm WH';
          wallHingeGapT.setAttribute('x', x + wallHingeGapW / 2); wallHingeGapT.setAttribute('y', 75);
          wallHingeGapT.setAttribute('text-anchor', 'middle'); wallHingeGapT.setAttribute('font-size', '10');
          wallHingeGapT.setAttribute('fill', '#666');
          svg.appendChild(wallHingeGapT);
          x += wallHingeGapW;
        }
        
        // Draw the gate
        const gateW = 890 * PX;
        const gateR = document.createElementNS(NS, 'rect');
        gateR.setAttribute('x', x); gateR.setAttribute('y', 20);
        gateR.setAttribute('width', gateW); gateR.setAttribute('height', 100);
        gateR.setAttribute('fill', '#90EE90'); gateR.setAttribute('stroke', '#333');
        gateR.setAttribute('stroke-width', '2');
        svg.appendChild(gateR);
        const gateT = document.createElementNS(NS, 'text');
        gateT.textContent = isWallToGlassHinge || isWallToGlassLatch ? 'WALL-GATE' : 'GATE';
        gateT.setAttribute('x', x + gateW / 2); gateT.setAttribute('y', 75);
        gateT.setAttribute('text-anchor', 'middle'); gateT.setAttribute('font-size', '14');
        gateT.setAttribute('font-weight', 'bold');
        gateT.setAttribute('fill', '#006400');
        svg.appendChild(gateT);
        x += gateW;
        
        // Draw latch gap after gate
        if (isWallToGlassLatch) {
          // Wall-to-glass latch: 7.5mm gap to wall
          const wallLatchGapW = 7.5 * PX;
          const wallLatchGapR = document.createElementNS(NS, 'rect');
          wallLatchGapR.setAttribute('x', x); wallLatchGapR.setAttribute('y', 20);
          wallLatchGapR.setAttribute('width', wallLatchGapW); wallLatchGapR.setAttribute('height', 100);
          wallLatchGapR.setAttribute('fill', '#ffb366'); wallLatchGapR.setAttribute('stroke', '#666'); // Different color for wall latch
          svg.appendChild(wallLatchGapR);
          const wallLatchGapT = document.createElementNS(NS, 'text');
          wallLatchGapT.textContent = '7.5mm WL';
          wallLatchGapT.setAttribute('x', x + wallLatchGapW / 2); wallLatchGapT.setAttribute('y', 75);
          wallLatchGapT.setAttribute('text-anchor', 'middle'); wallLatchGapT.setAttribute('font-size', '10');
          wallLatchGapT.setAttribute('fill', '#666');
          svg.appendChild(wallLatchGapT);
          x += wallLatchGapW;
        } else {
          // Standard 10mm latch gap
          const latchGapW = 10 * PX;
          const latchGapR = document.createElementNS(NS, 'rect');
          latchGapR.setAttribute('x', x); latchGapR.setAttribute('y', 20);
          latchGapR.setAttribute('width', latchGapW); latchGapR.setAttribute('height', 100);
          latchGapR.setAttribute('fill', '#ffcc99'); latchGapR.setAttribute('stroke', '#666');
          svg.appendChild(latchGapR);
          const latchGapT = document.createElementNS(NS, 'text');
          latchGapT.textContent = '10mm L';
          latchGapT.setAttribute('x', x + latchGapW / 2); latchGapT.setAttribute('y', 75);
          latchGapT.setAttribute('text-anchor', 'middle'); latchGapT.setAttribute('font-size', '10');
          latchGapT.setAttribute('fill', '#666');
          svg.appendChild(latchGapT);
          x += latchGapW;
        }
        
      } else {
        // Regular panel
        const w = pw * PX;
        const r = document.createElementNS(NS, 'rect');
        r.setAttribute('x', x); r.setAttribute('y', 20);
        r.setAttribute('width', w); r.setAttribute('height', 100);
        r.setAttribute('fill', '#a8d6ff'); 
        r.setAttribute('stroke', '#333');
        svg.appendChild(r);
        const t = document.createElementNS(NS, 'text');
        // Round panel width labels to two decimals when using continuous widths (glass-first mode)
        const disp = (PANEL_STEP <= 0 ? (Math.round(pw * 100) / 100).toFixed(2) : pw);
        t.textContent = disp;
        t.setAttribute('x', x + w / 2); t.setAttribute('y', 105);
        t.setAttribute('text-anchor', 'middle'); t.setAttribute('font-size', '12');
        t.setAttribute('font-weight', 'bold');
        t.setAttribute('fill', '#333');
        svg.appendChild(t);
        x += w;
        
        // Add normal gap after regular panel 
        const gPx = lay.gap * PX;
        const r2 = document.createElementNS(NS, 'rect');
        r2.setAttribute('x', x); r2.setAttribute('y', 20);
        r2.setAttribute('width', gPx); r2.setAttribute('height', 100);
        r2.setAttribute('fill', '#e8e8e8'); r2.setAttribute('stroke', '#666');
        svg.appendChild(r2);
        const t2 = document.createElementNS(NS, 'text');
        t2.textContent = rnd(lay.gap);
        t2.setAttribute('x', x + gPx / 2); t2.setAttribute('y', 75);
        t2.setAttribute('text-anchor', 'middle'); t2.setAttribute('font-size', '10');
        t2.setAttribute('fill', '#666');
        svg.appendChild(t2);
        x += gPx;
      }
    });

    viewElement.appendChild(svg);
  }

  // ─── Scroll-preserving wrapper for drawRows ─────────────────────────────────
  function drawRowsPreserveScroll() {
    // Save scroll position to global variables for drawRows to restore
    window.savedScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    window.savedScrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
    
    console.log(`Saving scroll position to globals: top=${window.savedScrollTop}, left=${window.savedScrollLeft}`);
    
    // Call the original drawRows (which will restore at the end)
    drawRows();
  }

  // ─── Draw the little rows ─────────────────────────────────
  function drawRows(){
    console.log('drawRows function called');
    
    // Don't draw elevation views if we're on the shape picker screen
    const calcCard = $('calcCard');
    const shapePicker = $('shapePicker');
    if (!calcCard || calcCard.style.display === 'none' || 
        !shapePicker || shapePicker.style.display !== 'none') {
      console.log('Skipping drawRows - not in calculation mode');
      return;
    }
    
    // Don't draw if we don't have valid layouts data
    if (!layouts || layouts.length === 0) {
      console.log('Skipping drawRows - no layouts data');
      return;
    }
    
    /* ── 1. remember where the user was ───────────────────── */
    const visual = $('visual');
    const savedTop = visual.scrollTop;                       // vertical
    const savedLefts = [...visual.querySelectorAll('.view')]
                        .map(v => v.scrollLeft);             // per-side H-scroll
    console.log(`Saving scroll positions: top=${savedTop}, lefts=[${savedLefts.join(',')}]`);
    
    /* ── 2. do the usual rebuild ──────────────────────────── */
    visual.innerHTML = '';
    
    const NS='http://www.w3.org/2000/svg';
    layouts.forEach((lay,i)=>{
      const wrap=document.createElement('div');
      wrap.style.margin='1rem 0';
      wrap.innerHTML=`<div style="font-weight:600;margin-bottom:4px">
        Side ${letters[i]} (${sideLens[i]} mm)
      </div><div class="view"></div>`;
      $('visual').appendChild(wrap);

      const gPx=lay.gap*PX,
            // Use original side length for SVG width when gate is present, otherwise use adjusted length
            actualLength = lay.gateSegment ? sideLens[i] : (lay.adjustedLength || sideLens[i]),
            svgW=actualLength*PX+MAR*2,
            svgH=140,
            svg=document.createElementNS(NS,'svg');
      svg.setAttribute('width',svgW);
      svg.setAttribute('viewBox',`0 0 ${svgW} ${svgH}`);

     

      let x=MAR;
      ;(function(){
        const r=document.createElementNS(NS,'rect');
        r.setAttribute('x',x);r.setAttribute('y',20);
        r.setAttribute('width',gPx);r.setAttribute('height',100);
        r.setAttribute('fill','#ddd');
        svg.appendChild(r);
        const t=document.createElementNS(NS,'text');
        t.textContent=rnd(lay.gap);
        t.setAttribute('x',x+gPx/2);t.setAttribute('y',16);
        t.setAttribute('text-anchor','middle');t.setAttribute('font-size','12');
        t.setAttribute('font-weight','bold');
        t.setAttribute('fill','#0077c8');
        svg.appendChild(t);
        x+=gPx;
      })();

      lay.panelWidths.forEach((pw, panelIndex) => {
        const w=pw*PX;
        const r=document.createElementNS(NS,'rect');
        r.setAttribute('x',x);r.setAttribute('y',20);
        r.setAttribute('width',w);r.setAttribute('height',100);
        r.setAttribute('fill','#a8d6ff');r.setAttribute('stroke','#333');
        svg.appendChild(r);
        const t=document.createElementNS(NS,'text');
        // Round panel width labels to 2 decimals when using continuous widths (glass-first mode)
        const disp = (PANEL_STEP <= 0 ? (Math.round(pw * 100) / 100).toFixed(2) : pw);
        t.textContent = disp;
        t.setAttribute('x',x+w/2);t.setAttribute('y',105);
        t.setAttribute('text-anchor','middle');t.setAttribute('font-size','12');
        t.setAttribute('font-weight','bold');
        t.setAttribute('fill','#333');
        svg.appendChild(t);
        x+=w;

        // Check if this panel is where the gate should be placed
        let gatePanelIndex = null;
        if (lay.gateSegment) {
          // Use panel index if available, otherwise fall back to position-based calculation
          if (lay.gateSegment.panelIndex !== undefined) {
            gatePanelIndex = lay.gateSegment.panelIndex;
          } else {
            // Legacy support for position-based system
            const totalPanels = lay.panelWidths.length;
            const position = lay.gateSegment.position || 'middle';
            
            if (position === 'left') {
              gatePanelIndex = Math.floor(totalPanels * 0.25); // 25% from left
            } else if (position === 'right') {
              gatePanelIndex = Math.floor(totalPanels * 0.75); // 75% from left  
            } else { // middle
              gatePanelIndex = Math.floor(totalPanels / 2); // 50% from left
            }
          }
        }
        
        if (lay.gateSegment && panelIndex === gatePanelIndex) {
          // Draw gate elements with dynamic orientation based on hingeOnLeft
          const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
          
          if (hingeOnLeft) {
            // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
            
            // 5mm hinge clearance
            const hingeW = 5 * PX;
            const hingeR = document.createElementNS(NS,'rect');
            hingeR.setAttribute('x',x);hingeR.setAttribute('y',20);
            hingeR.setAttribute('width',hingeW);hingeR.setAttribute('height',100);
            hingeR.setAttribute('fill','#ffcccc');hingeR.setAttribute('stroke','#666');
            svg.appendChild(hingeR);
            const hingeT = document.createElementNS(NS,'text');
            hingeT.textContent='5mm H';
            hingeT.setAttribute('x',x+hingeW/2);hingeT.setAttribute('y',16);
            hingeT.setAttribute('text-anchor','middle');hingeT.setAttribute('font-size','9');
            hingeT.setAttribute('fill','#666');
            svg.appendChild(hingeT);
            x += hingeW;

            // 890mm gate panel
            const gateW = 890 * PX;
            const gateR = document.createElementNS(NS,'rect');
            gateR.setAttribute('x',x);gateR.setAttribute('y',20);
            gateR.setAttribute('width',gateW);gateR.setAttribute('height',100);
            gateR.setAttribute('fill','#90EE90');gateR.setAttribute('stroke','#333');
            gateR.setAttribute('stroke-width','2');
            svg.appendChild(gateR);
            const gateT = document.createElementNS(NS,'text');
            gateT.textContent='890mm GATE';
            gateT.setAttribute('x',x+gateW/2);gateT.setAttribute('y',75);
            gateT.setAttribute('text-anchor','middle');gateT.setAttribute('font-size','14');
            gateT.setAttribute('font-weight','bold');
            gateT.setAttribute('fill','#006400');
            svg.appendChild(gateT);
            
            // Add hinge graphics on the left side of gate
            const hingeGraphic1 = document.createElementNS(NS,'rect');
            hingeGraphic1.setAttribute('x', x - 3);
            hingeGraphic1.setAttribute('y', 35);
            hingeGraphic1.setAttribute('width', 8);
            hingeGraphic1.setAttribute('height', 15);
            hingeGraphic1.setAttribute('fill', '#333');
            hingeGraphic1.setAttribute('stroke', '#000');
            hingeGraphic1.setAttribute('stroke-width', '1');
            svg.appendChild(hingeGraphic1);
            
            const hingeGraphic2 = document.createElementNS(NS,'rect');
            hingeGraphic2.setAttribute('x', x - 3);
            hingeGraphic2.setAttribute('y', 80);
            hingeGraphic2.setAttribute('width', 8);
            hingeGraphic2.setAttribute('height', 15);
            hingeGraphic2.setAttribute('fill', '#333');
            hingeGraphic2.setAttribute('stroke', '#000');
            hingeGraphic2.setAttribute('stroke-width', '1');
            svg.appendChild(hingeGraphic2);
            
            // Add latch graphic on the right side of gate
            const latchGraphic = document.createElementNS(NS,'rect');
            latchGraphic.setAttribute('x', x + gateW - 15);
            latchGraphic.setAttribute('y', 63);
            latchGraphic.setAttribute('width', 12);
            latchGraphic.setAttribute('height', 12);
            latchGraphic.setAttribute('fill', '#333');
            latchGraphic.setAttribute('stroke', '#000');
            latchGraphic.setAttribute('stroke-width', '2');
            svg.appendChild(latchGraphic);
            
            x += gateW;

            // 10mm latch clearance
            const latchW = 10 * PX;
            const latchR = document.createElementNS(NS,'rect');
            latchR.setAttribute('x',x);latchR.setAttribute('y',20);
            latchR.setAttribute('width',latchW);latchR.setAttribute('height',100);
            latchR.setAttribute('fill','#ccffcc');latchR.setAttribute('stroke','#666');
            svg.appendChild(latchR);
            const latchT = document.createElementNS(NS,'text');
            latchT.textContent='10mm L';
            latchT.setAttribute('x',x+latchW/2);latchT.setAttribute('y',16);
            latchT.setAttribute('text-anchor','middle');latchT.setAttribute('font-size','9');
            latchT.setAttribute('fill','#666');
            svg.appendChild(latchT);
            x += latchW;
            
          } else {
            // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
            
            // 10mm latch clearance
            const latchW = 10 * PX;
            const latchR = document.createElementNS(NS,'rect');
            latchR.setAttribute('x',x);latchR.setAttribute('y',20);
            latchR.setAttribute('width',latchW);latchR.setAttribute('height',100);
            latchR.setAttribute('fill','#ccffcc');latchR.setAttribute('stroke','#666');
            svg.appendChild(latchR);
            const latchT = document.createElementNS(NS,'text');
            latchT.textContent='10mm L';
            latchT.setAttribute('x',x+latchW/2);latchT.setAttribute('y',16);
            latchT.setAttribute('text-anchor','middle');latchT.setAttribute('font-size','9');
            latchT.setAttribute('fill','#666');
            svg.appendChild(latchT);
            x += latchW;

            // 890mm gate panel
            const gateW = 890 * PX;
            const gateR = document.createElementNS(NS,'rect');
            gateR.setAttribute('x',x);gateR.setAttribute('y',20);
            gateR.setAttribute('width',gateW);gateR.setAttribute('height',100);
            gateR.setAttribute('fill','#90EE90');gateR.setAttribute('stroke','#333');
            gateR.setAttribute('stroke-width','2');
            svg.appendChild(gateR);
            const gateT = document.createElementNS(NS,'text');
            gateT.textContent='890mm GATE';
            gateT.setAttribute('x',x+gateW/2);gateT.setAttribute('y',75);
            gateT.setAttribute('text-anchor','middle');gateT.setAttribute('font-size','14');
            gateT.setAttribute('font-weight','bold');
            gateT.setAttribute('fill','#006400');
            svg.appendChild(gateT);
            
            // Add latch graphic on the left side of gate
            const latchGraphic = document.createElementNS(NS,'rect');
            latchGraphic.setAttribute('x', x - 12);
            latchGraphic.setAttribute('y', 65);
            latchGraphic.setAttribute('width', 10);
            latchGraphic.setAttribute('height', 10);
            latchGraphic.setAttribute('fill', '#333');
            latchGraphic.setAttribute('stroke', '#000');
            latchGraphic.setAttribute('stroke-width', '2');
            svg.appendChild(latchGraphic);
            
            // Add hinge graphics on the right side of gate
            const hingeGraphic1 = document.createElementNS(NS,'rect');
            hingeGraphic1.setAttribute('x', x + gateW - 5);
            hingeGraphic1.setAttribute('y', 35);
            hingeGraphic1.setAttribute('width', 8);
            hingeGraphic1.setAttribute('height', 15);
            hingeGraphic1.setAttribute('fill', '#333');
            hingeGraphic1.setAttribute('stroke', '#000');
            hingeGraphic1.setAttribute('stroke-width', '1');
            svg.appendChild(hingeGraphic1);
            
            const hingeGraphic2 = document.createElementNS(NS,'rect');
            hingeGraphic2.setAttribute('x', x + gateW - 5);
            hingeGraphic2.setAttribute('y', 80);
            hingeGraphic2.setAttribute('width', 8);
            hingeGraphic2.setAttribute('height', 15);
            hingeGraphic2.setAttribute('fill', '#333');
            hingeGraphic2.setAttribute('stroke', '#000');
            hingeGraphic2.setAttribute('stroke-width', '1');
            svg.appendChild(hingeGraphic2);
            
            x += gateW;

            // 5mm hinge clearance
            const hingeW = 5 * PX;
            const hingeR = document.createElementNS(NS,'rect');
            hingeR.setAttribute('x',x);hingeR.setAttribute('y',20);
            hingeR.setAttribute('width',hingeW);hingeR.setAttribute('height',100);
            hingeR.setAttribute('fill','#ffcccc');hingeR.setAttribute('stroke','#666');
            svg.appendChild(hingeR);
            const hingeT = document.createElementNS(NS,'text');
            hingeT.textContent='5mm H';
            hingeT.setAttribute('x',x+hingeW/2);hingeT.setAttribute('y',16);
            hingeT.setAttribute('text-anchor','middle');hingeT.setAttribute('font-size','9');
            hingeT.setAttribute('fill','#666');
            svg.appendChild(hingeT);
            x += hingeW;
          }
        } else {
          // Regular gap
          const r2=document.createElementNS(NS,'rect');
          r2.setAttribute('x',x);r2.setAttribute('y',20);
          r2.setAttribute('width',gPx);r2.setAttribute('height',100);
          r2.setAttribute('fill','#ddd');
          svg.appendChild(r2);
          const t2=document.createElementNS(NS,'text');
          t2.textContent=rnd(lay.gap);
          t2.setAttribute('x',x+gPx/2);t2.setAttribute('y',16);
          t2.setAttribute('text-anchor','middle');t2.setAttribute('font-size','12');
          t2.setAttribute('font-weight','bold');
          t2.setAttribute('fill','#0077c8');
          svg.appendChild(t2);
          x+=gPx;
        }
      });

      wrap.querySelector('.view').appendChild(svg);
      
      // Add live gate position controls for sides with gates
      if (lay.gateSegment) {
        console.log(`Creating gate controls for side ${i}`);
        // Get current gate panel index (preserve existing position)
        let currentPanelIndex = lay.gateSegment.panelIndex;
        if (currentPanelIndex === undefined) {
          currentPanelIndex = Math.floor(lay.panelWidths.length / 2);
          lay.gateSegment.panelIndex = currentPanelIndex;
          lay.gateSegment.hingePanelIndex = lay.gateSegment.hingeOnLeft ? currentPanelIndex : currentPanelIndex + 1;
        }
        
        const totalPanels = lay.panelWidths.length;
        
        const gateControlsDiv = document.createElement('div');
        gateControlsDiv.style.cssText = 'margin-top:8px; padding:12px; background:linear-gradient(135deg, #f8fbff 0%, #e8f4ff 100%); border-radius:10px; border:1px solid #c5e1ff; box-shadow:0 2px 10px rgba(0,119,200,0.12);';
        gateControlsDiv.innerHTML = `
          <div style="display:flex; flex-direction:column; gap:0.5rem; align-items:flex-start;">
            <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:wrap;">
              <span style="font-size:0.9rem; color:#0066cc; font-weight:600; display:flex; align-items:center; gap:0.3rem;">🚪 Position:</span>
              <span class="liveGatePositionDisplay" data-side="${i}" style="font-size:0.8rem; color:#0066cc; text-align:center; font-weight:600; padding:0.3rem 0.6rem; background:#fff; border-radius:6px; border:1px solid #d4e6ff; box-shadow:0 1px 3px rgba(0,119,200,0.1);">Hinge: Panel ${currentPanelIndex}, Gate: Panel ${currentPanelIndex + 1}</span>
            </div>
            <div style="display:flex; align-items:center; gap:0.5rem; flex-wrap:nowrap; overflow-x:auto; width:100%; justify-content:flex-start;">
              <button type="button" class="liveGateFlip" data-side="${i}" onclick="flipGate(${i})" title="Flip Hinge-Gate Orientation"><span class="icon">🔄</span><span class="label">Flip Hinge-Gate Orientation</span></button>
              <button type="button" class="liveGateLeft" data-side="${i}" onclick="moveGate(${i}, 'left')" ${currentPanelIndex <= 0 ? 'disabled' : ''} title="Move Hinge-Gate Left"><span class="icon">←</span><span class="label">Move Hinge-Gate Left</span></button>
              <button type="button" class="liveGateRight" data-side="${i}" onclick="moveGate(${i}, 'right')" ${currentPanelIndex >= totalPanels - 2 ? 'disabled' : ''} title="Move Hinge-Gate Right"><span class="icon">→</span><span class="label">Move Hinge-Gate Right</span></button>
            </div>
          </div>
        `;
        wrap.appendChild(gateControlsDiv);
      }
    });
    
    /* ── 3. jump back to the same spot ────────────────────── */
    visual.scrollTop = savedTop;
    [...visual.querySelectorAll('.view')].forEach((v,i)=>{
      v.scrollLeft = savedLefts[i] ?? 0;
    });
    console.log(`Restored scroll positions: top=${savedTop}, restored ${savedLefts.length} view scroll positions`);
  }

  // Simple global functions for gate controls - SIMPLIFIED APPROACH
  function moveGate(sideIndex, direction) {
    console.log(`=== BUTTON CLICK DETECTED: moveGate called with side ${sideIndex}, direction ${direction} ===`);
    console.log(`=== moveGate called: side ${sideIndex}, direction ${direction} ===`);
    const layout = layouts[sideIndex];
    if (!layout || !layout.gateSegment) {
      console.log('ERROR: No layout or gate segment found!');
      return;
    }
    
    let currentPanelIndex = layout.gateSegment.panelIndex !== undefined ? layout.gateSegment.panelIndex : Math.floor(layout.panelWidths.length / 2);
    let hi = layout.gateSegment.hingeOnLeft ? currentPanelIndex : currentPanelIndex + 1;   // hinge panel's slot
    const totalPanels = layout.panelWidths.length;
    
    console.log(`BEFORE: Gate at panel ${currentPanelIndex}, Hinge at slot ${hi}, Total panels: ${totalPanels}`);
    console.log(`BEFORE: Panel widths:`, layout.panelWidths);
    console.log(`BEFORE: hingeOnLeft = ${layout.gateSegment.hingeOnLeft}`);
    
    // Save the original hinge index for debugging
    const originalHi = hi;
    
    // Unrestricted movement - gate can go anywhere from 0 to N-1
    const hingeOnLeft = layout.gateSegment.hingeOnLeft !== undefined ? layout.gateSegment.hingeOnLeft : false;
    
    console.log(`BEFORE MOVEMENT: Gate at panel ${currentPanelIndex}, hingeOnLeft=${hingeOnLeft}`);
    console.log(`BEFORE MOVEMENT: Array length=${layout.panelWidths.length}`);
    
    // Calculate new position (SINGLE calculation only)
    let newPanelIndex = currentPanelIndex;
    
    // Calculate movement boundaries - allow movement as long as final positions are valid
    // After movement, we need both gate and hinge to fit in the array
    let canMoveLeft = false;
    let canMoveRight = false;
    
    if (direction === 'left' && currentPanelIndex > 0) {
      const testGatePos = currentPanelIndex - 1;
      const testHingePos = hingeOnLeft ? testGatePos : testGatePos + 1;
      // Can move left if both positions are valid (>= 0)
      canMoveLeft = testGatePos >= 0 && testHingePos >= 0;
    }
    
    if (direction === 'right' && currentPanelIndex < totalPanels - 1) {
      const testGatePos = currentPanelIndex + 1;
      const testHingePos = hingeOnLeft ? testGatePos : testGatePos + 1;
      // Can move right if both positions are valid (< totalPanels)
      canMoveRight = testGatePos < totalPanels && testHingePos < totalPanels;
    }
    
    console.log(`Movement check: left=${canMoveLeft}, right=${canMoveRight}, current=${currentPanelIndex}`);
    
    if (direction === 'left' && canMoveLeft) {
      newPanelIndex = currentPanelIndex - 1;
      console.log(`LEFT movement: ${currentPanelIndex} -> ${newPanelIndex}`);
    } else if (direction === 'right' && canMoveRight) {
      newPanelIndex = currentPanelIndex + 1;
      console.log(`RIGHT movement: ${currentPanelIndex} -> ${newPanelIndex}`);
    } else {
      console.log(`Cannot move gate further ${direction} - would exceed bounds`);
      return;
    }
    
    // SIMPLE ARRAY MANIPULATION: Move hinge panel to follow gate
    const oldHingeIndex = layout.gateSegment.hingePanelIndex;
    const targetHingeIndex = hingeOnLeft ? newPanelIndex : newPanelIndex + 1;
    
    console.log(`TARGET POSITIONS: Gate=${newPanelIndex}, Hinge=${targetHingeIndex}`);
    console.log(`CURRENT POSITIONS: Gate=${currentPanelIndex}, Hinge=${oldHingeIndex}`);
    
    // Only move if the hinge position actually changed
    if (oldHingeIndex !== undefined && oldHingeIndex !== targetHingeIndex) {
      // Remove hinge panel from old position
      const hingeWidth = layout.panelWidths.splice(oldHingeIndex, 1)[0];
      console.log(`Removed hinge panel width ${hingeWidth} from position ${oldHingeIndex}`);
      
      // Adjust target positions based on removal
      let finalGateIndex = newPanelIndex;
      let finalHingeIndex = targetHingeIndex;
      
      if (oldHingeIndex < newPanelIndex) {
        // Hinge was before gate, so gate position shifts down
        finalGateIndex = newPanelIndex - 1;
        finalHingeIndex = hingeOnLeft ? finalGateIndex : finalGateIndex + 1;
        console.log(`Adjusted positions due to hinge removal: Gate=${finalGateIndex}, Hinge=${finalHingeIndex}`);
      }
      
      // Insert hinge panel at new position
      layout.panelWidths.splice(finalHingeIndex, 0, hingeWidth);
      console.log(`Inserted hinge panel at position ${finalHingeIndex}`);
      
      // Update tracking with final positions
      layout.gateSegment.panelIndex = finalGateIndex;
      layout.gateSegment.hingePanelIndex = finalHingeIndex;
      
      console.log(`FINAL POSITIONS: Gate=${layout.gateSegment.panelIndex}, Hinge=${layout.gateSegment.hingePanelIndex}`);
    } else {
      // No hinge movement needed, just update gate position
      layout.gateSegment.panelIndex = newPanelIndex;
      console.log(`No hinge movement needed. Gate position: ${newPanelIndex}`);
    }
    
    // Redraw everything (drawRows will preserve scroll position automatically)
    drawRows();
    
    console.log('=== moveGate completed ===');
  }

  function flipGate(sideIndex) {
    console.log(`=== BUTTON CLICK DETECTED: flipGate called with side ${sideIndex} ===`);
    console.log(`flipGate called: side ${sideIndex}`);
    const layout = layouts[sideIndex];
    if (!layout || !layout.gateSegment) return;
    
    const gi = layout.gateSegment.panelIndex;
    const oldHi = layout.gateSegment.hingeOnLeft ? gi : gi + 1;
    const hingeWidth = layout.panelWidths.splice(oldHi, 1)[0];
    
    // Toggle hinge orientation
    layout.gateSegment.hingeOnLeft = !layout.gateSegment.hingeOnLeft;
    console.log(`Flipped gate orientation: hingeOnLeft = ${layout.gateSegment.hingeOnLeft}`);
    
    const newHi = layout.gateSegment.hingeOnLeft ? gi : gi + 1;
    layout.panelWidths.splice(newHi, 0, hingeWidth);
    
    // Update hinge panel index tracking
    layout.gateSegment.hingePanelIndex = newHi;
    
    // Redraw everything (drawRows will preserve scroll position automatically)
    drawRows();
  }

  // ─── Full‐plan SVG, PNG & PDF ──────────────────────────────
  function buildPlanSVG(layouts,runs){
    const NS='http://www.w3.org/2000/svg',BAR=15,GAPF=8,PANF=10;
    
    // Use custom shape data if available, otherwise default to orthogonal directions
    const useCustomDirections = window.customShapeData && window.customShapeData.isCustom;
    let pts=[[0,0]],x=0,y=0;
    
    if (useCustomDirections) {
      // Use actual direction vectors from custom shape
      const customRuns = window.customShapeData.runs;
      const scale = 0.001; // Convert mm to plan units
      customRuns.forEach((run, i) => {
        x += run.dx * scale;
        y += run.dy * scale;
        pts.push([x, y]);
      });
    } else {
      // Use default orthogonal directions for standard shapes
      const dirs=[[1,0],[0,1],[-1,0],[0,-1]];
      runs.forEach((l,i)=>{ x+=dirs[i%4][0]*l; y+=dirs[i%4][1]*l; pts.push([x,y]); });
    }
    
    const minX=Math.min(...pts.map(p=>p[0])),minY=Math.min(...pts.map(p=>p[1]));
    pts=pts.map(([px,py])=>[(px-minX)*PX+MAR,(py-minY)*PX+MAR]);
    const W=Math.max(...pts.map(p=>p[0]))+MAR,H=Math.max(...pts.map(p=>p[1]))+MAR;
    const svg=document.createElementNS(NS,'svg');
    svg.setAttribute('xmlns',NS);
    svg.setAttribute('width',W);
    svg.setAttribute('height',H);
    svg.setAttribute('fill','none');
    const poly=document.createElementNS(NS,'polyline');
    poly.setAttribute('points',pts.map(p=>p.join(',')).join(' '));
    poly.setAttribute('stroke','#000');
    poly.setAttribute('stroke-width','2');
    svg.appendChild(poly);

    let cx=pts[0][0],cy=pts[0][1];
    layouts.forEach((lay,i)=>{
      // Calculate direction for this segment
      let dx, dy;
      if (useCustomDirections && window.customShapeData.runs[i]) {
        const run = window.customShapeData.runs[i];
        const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
        dx = run.dx / length; // Normalize to unit vector
        dy = run.dy / length;
      } else {
        // Use default orthogonal directions
        const dirs=[[1,0],[0,1],[-1,0],[0,-1]];
        [dx,dy] = dirs[i%4];
      }
      
      // Debug: Check if this side's layout matches expectations
      if (i === 2) { // Side C debug
        console.log(`PLAN VIEW Side C: dx=${dx}, dy=${dy}, panels=[${lay.panelWidths.join(', ')}]`);
        console.log(`Side C layout object:`, lay);
      }
      
function seg(mm,col,lab,isP){
  const len=mm*PX,w=dx?len:BAR,h=dy?len:BAR,rx=dx<0?-w:0,ry=dy<0?-h:0;
  const r=document.createElementNS(NS,'rect');
  r.setAttribute('x',cx+rx);r.setAttribute('y',cy+ry);
  r.setAttribute('width',w);r.setAttribute('height',h);r.setAttribute('fill',col);
  if(isP) r.setAttribute('stroke','#333');
  svg.appendChild(r);

  // Panel label - REMOVED to avoid duplication (handled in panelWidths.forEach)
  // if(isP){
  //   Panel measurements now handled in the panelWidths.forEach loop
  // }
  
  if(!isP) {
    // Gap label - positioned on OUTSIDE of fence perimeter (except corners)
    const t=document.createElementNS(NS,'text');
    t.textContent = `${lab}`;
    t.setAttribute('font-size', '18');
    t.setAttribute('font-weight', 'bold');
    t.setAttribute('fill', '#0077c8');
    t.setAttribute('text-anchor','middle');
    t.setAttribute('dominant-baseline','middle');
    
    // Check if this is a corner gap - simpler approach based on side transitions
    // Corner gaps occur at the start of each side (except first side which we skip)
    const isCornerGap = (i > 0); // All sides after the first start at a corner
    
    if(dx){
      // Horizontal gap - position based on direction
      if (dx > 0) {
        // Moving right (Side A) - put gap text ABOVE fence line (outside)
        t.setAttribute('x',cx+rx+w/2); 
        t.setAttribute('y',cy+ry-15);
      } else {
        // Moving left (Side C) - put gap text BELOW fence line (outside)
        t.setAttribute('x',cx+rx+w/2); 
        t.setAttribute('y',cy+ry+h+25);
      }
    }else{
      // Vertical gap - position based on direction
      if (dy > 0) {
        // Moving down (Side B) - put gap text to RIGHT of fence line (outside)
        t.setAttribute('x',cx+rx+w+25);
        t.setAttribute('y',cy+ry+h/2);
        t.setAttribute('transform', `rotate(90 ${cx+rx+w+25} ${cy+ry+h/2})`);
      } else {
        // Moving up (Side D) - put gap text to LEFT of fence line (outside)
        t.setAttribute('x',cx+rx-25);
        t.setAttribute('y',cy+ry+h/2);
        t.setAttribute('transform', `rotate(90 ${cx+rx-25} ${cy+ry+h/2})`);
      }
    }
    svg.appendChild(t);
  }
  cx+=dx*len;cy+=dy*len;
}
      // Determine if this side should have start/end gaps based on shape configuration
      // Gaps appear between fence sections, but not at overlap points where sides connect
      let hasStartGap = true;
      let hasEndGap = true;
      
      if (curShape) {
        if (curShape.id === 'U') {
          // U shape (3 sides): A(top)-B(right)-C(bottom)
          if (i === 0) {
            // Side A (top): Start gap ✓, End gap ✓ (between connections to B)
            hasStartGap = true;
            hasEndGap = true;
          } else if (i === 1) {
            // Side B (right): No start gap, No end gap (overlaps with A and C)
            hasStartGap = false;
            hasEndGap = false;
          } else if (i === 2) {
            // Side C (bottom): Start gap ✓, End gap ✓ (between connections to B)
            hasStartGap = true;
            hasEndGap = true;
          }
        } else if (curShape.id === 'BOX') {
          // BOX shape (4 sides): A(top)-B(right)-C(bottom)-D(left)
          if (i === 0) {
            // Side A (top): Start gap ✓, End gap ✓ (between connections to B & D)
            hasStartGap = true;
            hasEndGap = true;
          } else if (i === 1) {
            // Side B (right): No start gap, No end gap (overlaps with A and C)
            hasStartGap = false;
            hasEndGap = false;
          } else if (i === 2) {
            // Side C (bottom): Start gap ✓, End gap ✓ (between connections to B & D)
            hasStartGap = true;
            hasEndGap = true;
          } else if (i === 3) {
            // Side D (left): No start gap, No end gap (overlaps with A and C)
            hasStartGap = false;
            hasEndGap = false;
          }
        } else if (curShape.id === 'L') {
          // L shape (2 sides): A(top)-B(right)
          if (i === 0) {
            // Side A (top): Start gap ✓, End gap ✓ (between connections to B)
            hasStartGap = true;
            hasEndGap = true;
          } else if (i === 1) {
            // Side B (right): No start gap (overlaps A), End gap ✓
            hasStartGap = false;
            hasEndGap = true;
          }
        }
        // INLINE shape: single side, has both start and end gaps (default)
      }
      
      // For Side C (moving left) and Side D (moving up), reverse the panel order to match elevation view display
      let panelsToProcess = lay.panelWidths;
      if (i === 2 && dx < 0) { // Side C moving left
        panelsToProcess = [...lay.panelWidths].reverse();
        console.log(`Side C panels reversed: [${panelsToProcess.join(', ')}]`);
      } else if (i === 3 && dy < 0) { // Side D moving up
        panelsToProcess = [...lay.panelWidths].reverse();
        console.log(`Side D panels reversed: [${panelsToProcess.join(', ')}]`);
      }

      // Draw initial gap only for sides that should have one
      if(hasStartGap) {
        if (i === 2) { // Side C - make gap white to show overlap clearly
          seg(lay.gap,'#ffffff','',false);
        } else {
          seg(lay.gap,'#ddd',rnd(lay.gap),false);
        }
      }
panelsToProcess.forEach((pw, panelIndex) => {
  // Save current position before drawing
  const prevCx = cx, prevCy = cy;

  // Draw panel
  seg(pw,'#a8d6ff',pw,true);

  // Calculate panel center for label
  const panelLen = pw * PX;
  let panelCenterX, panelCenterY;
  
  if (dx) {
    // Horizontal movement
    if (dx > 0) {
      // Moving right - panel extends from prevCx to prevCx + panelLen
      panelCenterX = prevCx + panelLen / 2;
    } else {
      // Moving left - panel extends from prevCx - panelLen to prevCx
      panelCenterX = prevCx - panelLen / 2;
    }
    panelCenterY = prevCy;
  } else {
    // Vertical movement
    panelCenterX = prevCx;
    if (dy > 0) {
      // Moving down - panel extends from prevCy to prevCy + panelLen
      panelCenterY = prevCy + panelLen / 2;
    } else {
      // Moving up - panel extends from prevCy - panelLen to prevCy
      panelCenterY = prevCy - panelLen / 2;
    }
  }

  // Add panel measurement label
const t = document.createElementNS(NS,'text');
t.textContent = `${pw} mm`;
t.setAttribute('font-size', '25');           // Larger
t.setAttribute('font-weight', 'bold');        // Bold
t.setAttribute('fill', '#111');               // Black
  if (dx) {
    // Horizontal panel - position measurement based on direction
    t.setAttribute('x', panelCenterX);
    if (dx > 0) {
      // Moving right (Side A) - put text BELOW panel (inside)
      t.setAttribute('y', prevCy + 35); 
    } else {
      // Moving left (Side C) - put text ABOVE panel (inside)  
      t.setAttribute('y', prevCy - 10);
    }
    t.setAttribute('text-anchor', 'middle');
  } else {
    // Vertical panel - position measurement based on direction
    if (dy > 0) {
      // Moving down (Side B) - put text to LEFT of panel (inside)
      t.setAttribute('x', prevCx - 25);
      t.setAttribute('y', panelCenterY);
      t.setAttribute('dominant-baseline', 'middle');
      t.setAttribute('transform', `rotate(90 ${prevCx - 25} ${panelCenterY})`);
    } else {
      // Moving up (Side D) - put text to RIGHT of panel (inside)
      t.setAttribute('x', prevCx + BAR + 25);
      t.setAttribute('y', panelCenterY);
      t.setAttribute('dominant-baseline', 'middle');
      t.setAttribute('transform', `rotate(90 ${prevCx + BAR + 25} ${panelCenterY})`);
    }
  }
  svg.appendChild(t);

  // Check if this panel is where the gate should be placed
  let gatePanelIndex = null;
  if (lay.gateSegment) {
    // Use panelIndex for precise gate positioning, fallback to position-based for legacy
    if (lay.gateSegment.panelIndex !== undefined) {
      gatePanelIndex = lay.gateSegment.panelIndex;
    } else {
      const totalPanels = lay.panelWidths.length;
      const position = lay.gateSegment.position || 'middle';
      
      // Calculate gate panel index based on position (legacy support)
      if (position === 'left') {
        gatePanelIndex = Math.floor(totalPanels * 0.25); // 25% from left
      } else if (position === 'right') {
        gatePanelIndex = Math.floor(totalPanels * 0.75); // 75% from left  
      } else { // middle
        gatePanelIndex = Math.floor(totalPanels / 2); // 50% from left
      }
    }
  }
  
  if (lay.gateSegment && panelIndex === gatePanelIndex) {
    // Draw gate elements with dynamic orientation based on hingeOnLeft
    const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
    
    if (hingeOnLeft) {
      // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
      seg(5,'#ffcccc','5mm H',false);
      seg(890,'#90EE90','GATE',true);
      seg(10,'#ccffcc','10mm L',false);
    } else {
      // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
      seg(10,'#ccffcc','10mm L',false);
      seg(890,'#90EE90','GATE',true);
      seg(5,'#ffcccc','5mm H',false);
    }
  } else {
    // Draw regular gap after panel, but only if this isn't the last panel of a side that shouldn't have end gaps
    const isLastPanel = (panelIndex === lay.panelWidths.length - 1);
    const shouldDrawGap = !isLastPanel || hasEndGap;
    
    if (shouldDrawGap) {
      seg(lay.gap,'#ddd',rnd(lay.gap),false);
    }
  }
});

// Draw gap at the end of each side only if it should have one
if(hasEndGap) {
  if (i === 2) { // Side C - make gap white to show overlap clearly
    seg(lay.gap,'#ffffff','',false);
  } else {
    seg(lay.gap,'#ddd',rnd(lay.gap),false);
  }
}
    });

    const defs=document.createElementNS(NS,'defs');
    defs.innerHTML=`<marker id="arr" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto" markerUnits="strokeWidth"><path d="M0 0 L10 5 L0 10 Z" fill="#ff0000"/></marker>`;
    svg.appendChild(defs);

    function arrow(x1,y1,x2,y2,txt,vert,direction){
      const l=document.createElementNS(NS,'line');
      l.setAttribute('x1',x1);l.setAttribute('y1',y1);
      l.setAttribute('x2',x2);l.setAttribute('y2',y2);
      l.setAttribute('stroke','#ff0000');  // Make red for visibility
      l.setAttribute('stroke-width','4');   // Much thicker lines
      l.setAttribute('marker-start','url(#arr)');
      l.setAttribute('marker-end','url(#arr)');
      svg.appendChild(l);
      
      const t=document.createElementNS(NS,'text');
      t.textContent=`${txt} mm`;
      t.setAttribute('font-size', '22');    // Even bigger font for readability
      t.setAttribute('font-weight','bold');
      t.setAttribute('fill','#ff0000');     // Red text to match arrow
      t.setAttribute('text-anchor','middle');
      t.setAttribute('dominant-baseline','middle');
      
      if(vert){
        // For vertical arrows, position text on the OUTSIDE
        if(direction === 'right') {
          // Arrow is to the right of fence, put text further right
          t.setAttribute('x', x1 + 30);
          t.setAttribute('y', (y1+y2)/2);
          t.setAttribute('transform',`rotate(90 ${x1+30} ${(y1+y2)/2})`);  // Changed to +90
        } else {
          // Arrow is to the left of fence, put text further left
          t.setAttribute('x', x1 - 30);
          t.setAttribute('y', (y1+y2)/2);
          t.setAttribute('transform',`rotate(90 ${x1-30} ${(y1+y2)/2})`);  // Changed to +90
        }
      } else {
        // For horizontal arrows, position text on the OUTSIDE
        if(direction === 'above') {
          // Arrow is above fence, put text further above
          t.setAttribute('x',(x1+x2)/2);
          t.setAttribute('y',y1-25);
        } else {
          // Arrow is below fence, put text further below
          t.setAttribute('x',(x1+x2)/2);
          t.setAttribute('y',y1+35);
        }
      }
      svg.appendChild(t);
    }

const letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];

for (let i = 0; i < runs.length; i++) {
  const pStart = pts[i];
  const pEnd = pts[i + 1];
  if (!pStart || !pEnd) continue;
  
  // Calculate direction of this side
  const dx = pEnd[0] - pStart[0];
  const dy = pEnd[1] - pStart[1];
  const isHorizontal = Math.abs(dx) > Math.abs(dy);
  const offset = 80;  // Increased offset for more space
  
  let x1, y1, x2, y2, direction;
  
  if (isHorizontal) {
    // Horizontal side - put arrow above or below
    if (dx > 0) {
      // Moving right - put arrow above
      x1 = pStart[0];
      x2 = pEnd[0];
      y1 = y2 = pStart[1] - offset;
      direction = 'above';
    } else {
      // Moving left - put arrow below, but reverse direction for correct arrowheads
      x1 = pEnd[0];
      x2 = pStart[0];
      y1 = y2 = pStart[1] + offset;
      direction = 'below';
    }
  } else {
    // Vertical side - put arrow left or right
    if (dy > 0) {
      // Moving down - put arrow to the right
      y1 = pStart[1];
      y2 = pEnd[1];
      x1 = x2 = pStart[0] + offset;
      direction = 'right';
    } else {
      // Moving up - put arrow to the left, but reverse direction for correct arrowheads
      y1 = pEnd[1];
      y2 = pStart[1];
      x1 = x2 = pStart[0] - offset;
      direction = 'left';
    }
  }
  
  // Draw arrow with measurement, passing direction info
  arrow(x1, y1, x2, y2, `${letters[i]}: ${runs[i]}`, !isHorizontal, direction);
}

// Add overall run length label at the top left
const totalRun = runs.reduce((a, b) => a + b, 0);
const overallLabel = document.createElementNS(NS, 'text');
overallLabel.setAttribute('x', W/2);
overallLabel.setAttribute('y', 20); // slightly higher
overallLabel.setAttribute('text-anchor', 'middle');
overallLabel.setAttribute('font-size', '16');
overallLabel.setAttribute('font-weight', '700');
overallLabel.setAttribute('fill', '#0077c8');
svg.appendChild(overallLabel);

    return svg;
  }

  // ─── Custom Shape Plan SVG for accurate PDF generation ──────────────────────────
  function buildCustomPlanSVG(layouts, customRuns) {
    const NS='http://www.w3.org/2000/svg',BAR=15,GAPF=8,PANF=10,MAR=50,PX=0.1;
    
    // Constants for professional styling
    const INSET = 6; // Distance from red outline to blue panels
    const LABEL_OFFSET = 3; // Extra gap for blue/grey text beyond red arrows
    const PANEL_THICKNESS = 8;
    const PANEL_FONT = 10; // Larger font for better readability
    const GAP_FONT = 9; // Larger gap font for better readability
    
    // Build fence outline points using actual direction vectors
    let pts=[[0,0]],x=0,y=0;
    
    customRuns.forEach((run, i) => {
      x += run.dx * PX;
      y += run.dy * PX;
      pts.push([x, y]);
    });
    
    // Normalize to positive coordinates and add margins
    const minX=Math.min(...pts.map(p=>p[0])),minY=Math.min(...pts.map(p=>p[1]));
    pts=pts.map(([px,py])=>[(px-minX)+MAR,(py-minY)+MAR]);
    const W=Math.max(...pts.map(p=>p[0]))+MAR,H=Math.max(...pts.map(p=>p[1]))+MAR;
    
    // Create SVG
    const svg=document.createElementNS(NS,'svg');
    svg.setAttribute('xmlns',NS);
    svg.setAttribute('width',W);
    svg.setAttribute('height',H);
    svg.setAttribute('fill','none');

    // Add arrow markers first
    const defs = document.createElementNS(NS, 'defs');
    const marker = document.createElementNS(NS, 'marker');
    marker.setAttribute('id', 'arrowhead');
    marker.setAttribute('markerWidth', '10');
    marker.setAttribute('markerHeight', '7');
    marker.setAttribute('refX', '9');
    marker.setAttribute('refY', '3.5');
    marker.setAttribute('orient', 'auto');
    
    const polygon = document.createElementNS(NS, 'polygon');
    polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
    polygon.setAttribute('fill', '#d32f2f');
    marker.appendChild(polygon);
    defs.appendChild(marker);
    svg.appendChild(defs);

    // LAYER 1: Red outline + arrows (background)
    customRuns.forEach((run, i) => {
      if (!pts[i] || !pts[i + 1]) return;
      
      // Calculate outward normal for this side to offset arrows outside panels
      const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
      const normalX = -run.dy / length;
      const normalY = run.dx / length;
      
      // Offset arrow points well outside the panel area with extra clearance
      const extraOffset = INSET + PANEL_THICKNESS + 12; // Panel thickness + generous clearance
      const offsetStartX = pts[i][0] + normalX * extraOffset;
      const offsetStartY = pts[i][1] + normalY * extraOffset;
      const offsetEndX = pts[i + 1][0] + normalX * extraOffset;
      const offsetEndY = pts[i + 1][1] + normalY * extraOffset;
      
      // Arrow line (positioned outside panels)
      const arrowLine = document.createElementNS(NS,'line');
      arrowLine.setAttribute('x1', offsetStartX);
      arrowLine.setAttribute('y1', offsetStartY);
      arrowLine.setAttribute('x2', offsetEndX);
      arrowLine.setAttribute('y2', offsetEndY);
      arrowLine.setAttribute('stroke', '#d32f2f');
      arrowLine.setAttribute('stroke-width', '2');
      arrowLine.setAttribute('marker-end', 'url(#arrowhead)');
      arrowLine.setAttribute('marker-start', 'url(#arrowhead)');
      svg.appendChild(arrowLine);
      
      // Side length label (positioned away from blue panels)
      const midX = (offsetStartX + offsetEndX) / 2;
      const midY = (offsetStartY + offsetEndY) / 2;
      const dx = offsetEndX - offsetStartX;
      const dy = offsetEndY - offsetStartY;
      const dirLength = Math.sqrt(dx*dx + dy*dy);
      const labelNormalX = -dy / dirLength;
      const labelNormalY = dx / dirLength;
      const labelOffset = 15; // Reduced offset to keep text closer to arrow line
      
      const labelX = midX + labelNormalX * labelOffset;
      const labelY = midY + labelNormalY * labelOffset;
      
      const text = document.createElementNS(NS,'text');
      text.textContent = `${run.id}: ${Math.round(run.length)} mm`;
      text.setAttribute('x', labelX);
      text.setAttribute('y', labelY);
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('font-size', '14');
      text.setAttribute('font-weight', 'bold');
      text.setAttribute('fill', '#d32f2f');
      
      // Keep text upright: flip if it would be upside-down (more aggressive flipping)
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      const normalizedAngle = (angle + 360) % 360;
      const finalAngle = (normalizedAngle > 80 && normalizedAngle < 280) ? angle + 180 : angle;
      
      text.setAttribute('transform', `rotate(${finalAngle} ${labelX} ${labelY})`);
      svg.appendChild(text);
    });

    // LAYER 2: Blue panels (middle layer)
    layouts.forEach((lay,i)=>{
      const run = customRuns[i];
      const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
      const unitDx = run.dx / length;
      const unitDy = run.dy / length;
      
      // Calculate inset start position for this side's panels
      let currentX = 0, currentY = 0;
      for (let j = 0; j < i; j++) {
        currentX += customRuns[j].dx * PX;
        currentY += customRuns[j].dy * PX;
      }
      
      // Apply inset to move panels inside the outline
      const normalX = -unitDy;
      const normalY = unitDx;
      const insetX = normalX * INSET;
      const insetY = normalY * INSET;
      
      const startX = (currentX - minX) + MAR + insetX;
      const startY = (currentY - minY) + MAR + insetY;
      
      let sideProgress = 0;
      
      // Gate detection logic (same as 3D rendering)
      let gatePanelIndex = null;
      if (lay.gateSegment) {
        if (lay.gateSegment.panelIndex !== undefined) {
          gatePanelIndex = lay.gateSegment.panelIndex;
        } else {
          const totalPanels = lay.panelWidths.length;
          const position = lay.gateSegment.position || 'middle';
          if (position === 'left') {
            gatePanelIndex = Math.floor(totalPanels * 0.25);
          } else if (position === 'right') {
            gatePanelIndex = Math.floor(totalPanels * 0.75);
          } else {
            gatePanelIndex = Math.floor(totalPanels / 2);
          }
        }
      }
      
      lay.panelWidths.forEach((pw, panelIndex) => {
        const panelLen = pw * PX;
        
        const panelStartX = startX + sideProgress * unitDx;
        const panelStartY = startY + sideProgress * unitDy;
        const panelCenterX = panelStartX + (panelLen / 2) * unitDx;
        const panelCenterY = panelStartY + (panelLen / 2) * unitDy;
        
        // Create rotated rectangle for the panel
        const angle = Math.atan2(unitDy, unitDx) * 180 / Math.PI;
        const halfLen = panelLen / 2;
        const halfThick = PANEL_THICKNESS / 2;
        
        const corners = [
          [-halfLen, -halfThick], [halfLen, -halfThick], 
          [halfLen, halfThick], [-halfLen, halfThick]
        ];
        
        const rotatedCorners = corners.map(([x, y]) => {
          const cos = Math.cos(angle * Math.PI / 180);
          const sin = Math.sin(angle * Math.PI / 180);
          return [
            panelCenterX + (x * cos - y * sin),
            panelCenterY + (x * sin + y * cos)
          ];
        });
        
        // Blue panel
        const panel = document.createElementNS(NS,'polygon');
        panel.setAttribute('points', rotatedCorners.map(p => p.join(',')).join(' '));
        panel.setAttribute('fill', 'rgba(190,220,255,1)');
        panel.setAttribute('stroke', 'rgb(50,100,180)');
        panel.setAttribute('stroke-width', '0.25');
        svg.appendChild(panel);

        sideProgress += panelLen;
        
        // Gate handling: add gate segments instead of normal gap
        if (lay.gateSegment && panelIndex === gatePanelIndex && panelIndex < lay.panelWidths.length - 1) {
          const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
          
          if (hingeOnLeft) {
            // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
            // 5mm hinge (light red)
            const hingeLen = 5 * PX;
            const hingeStartX = startX + sideProgress * unitDx;
            const hingeStartY = startY + sideProgress * unitDy;
            const hingeCenterX = hingeStartX + (hingeLen / 2) * unitDx;
            const hingeCenterY = hingeStartY + (hingeLen / 2) * unitDy;
            
            const hingeCorners = [
              [-hingeLen/2, -halfThick], [hingeLen/2, -halfThick], 
              [hingeLen/2, halfThick], [-hingeLen/2, halfThick]
            ];
            
            const hingeRotatedCorners = hingeCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                hingeCenterX + (x * cos - y * sin),
                hingeCenterY + (x * sin + y * cos)
              ];
            });
            
            const hingePanel = document.createElementNS(NS,'polygon');
            hingePanel.setAttribute('points', hingeRotatedCorners.map(p => p.join(',')).join(' '));
            hingePanel.setAttribute('fill', '#ffcccc');
            hingePanel.setAttribute('stroke', '#cc9999');
            hingePanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(hingePanel);
            
            sideProgress += hingeLen;
            
            // 890mm gate (green)
            const gateLen = 890 * PX;
            const gateStartX = startX + sideProgress * unitDx;
            const gateStartY = startY + sideProgress * unitDy;
            const gateCenterX = gateStartX + (gateLen / 2) * unitDx;
            const gateCenterY = gateStartY + (gateLen / 2) * unitDy;
            
            const gateCorners = [
              [-gateLen/2, -halfThick], [gateLen/2, -halfThick], 
              [gateLen/2, halfThick], [-gateLen/2, halfThick]
            ];
            
            const gateRotatedCorners = gateCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                gateCenterX + (x * cos - y * sin),
                gateCenterY + (x * sin + y * cos)
              ];
            });
            
            const gatePanel = document.createElementNS(NS,'polygon');
            gatePanel.setAttribute('points', gateRotatedCorners.map(p => p.join(',')).join(' '));
            gatePanel.setAttribute('fill', '#90EE90');
            gatePanel.setAttribute('stroke', '#4CAF50');
            gatePanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(gatePanel);
            
            sideProgress += gateLen;
            
            // 10mm latch (light green)
            const latchLen = 10 * PX;
            const latchStartX = startX + sideProgress * unitDx;
            const latchStartY = startY + sideProgress * unitDy;
            const latchCenterX = latchStartX + (latchLen / 2) * unitDx;
            const latchCenterY = latchStartY + (latchLen / 2) * unitDy;
            
            const latchCorners = [
              [-latchLen/2, -halfThick], [latchLen/2, -halfThick], 
              [latchLen/2, halfThick], [-latchLen/2, halfThick]
            ];
            
            const latchRotatedCorners = latchCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                latchCenterX + (x * cos - y * sin),
                latchCenterY + (x * sin + y * cos)
              ];
            });
            
            const latchPanel = document.createElementNS(NS,'polygon');
            latchPanel.setAttribute('points', latchRotatedCorners.map(p => p.join(',')).join(' '));
            latchPanel.setAttribute('fill', '#ccffcc');
            latchPanel.setAttribute('stroke', '#99cc99');
            latchPanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(latchPanel);
            
            sideProgress += latchLen;
          } else {
            // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
            // 10mm latch (light green)
            const latchLen = 10 * PX;
            const latchStartX = startX + sideProgress * unitDx;
            const latchStartY = startY + sideProgress * unitDy;
            const latchCenterX = latchStartX + (latchLen / 2) * unitDx;
            const latchCenterY = latchStartY + (latchLen / 2) * unitDy;
            
            const latchCorners = [
              [-latchLen/2, -halfThick], [latchLen/2, -halfThick], 
              [latchLen/2, halfThick], [-latchLen/2, halfThick]
            ];
            
            const latchRotatedCorners = latchCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                latchCenterX + (x * cos - y * sin),
                latchCenterY + (x * sin + y * cos)
              ];
            });
            
            const latchPanel = document.createElementNS(NS,'polygon');
            latchPanel.setAttribute('points', latchRotatedCorners.map(p => p.join(',')).join(' '));
            latchPanel.setAttribute('fill', '#ccffcc');
            latchPanel.setAttribute('stroke', '#99cc99');
            latchPanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(latchPanel);
            
            sideProgress += latchLen;
            
            // 890mm gate (green)
            const gateLen = 890 * PX;
            const gateStartX = startX + sideProgress * unitDx;
            const gateStartY = startY + sideProgress * unitDy;
            const gateCenterX = gateStartX + (gateLen / 2) * unitDx;
            const gateCenterY = gateStartY + (gateLen / 2) * unitDy;
            
            const gateCorners = [
              [-gateLen/2, -halfThick], [gateLen/2, -halfThick], 
              [gateLen/2, halfThick], [-gateLen/2, halfThick]
            ];
            
            const gateRotatedCorners = gateCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                gateCenterX + (x * cos - y * sin),
                gateCenterY + (x * sin + y * cos)
              ];
            });
            
            const gatePanel = document.createElementNS(NS,'polygon');
            gatePanel.setAttribute('points', gateRotatedCorners.map(p => p.join(',')).join(' '));
            gatePanel.setAttribute('fill', '#90EE90');
            gatePanel.setAttribute('stroke', '#4CAF50');
            gatePanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(gatePanel);
            
            sideProgress += gateLen;
            
            // 5mm hinge (light red)
            const hingeLen = 5 * PX;
            const hingeStartX = startX + sideProgress * unitDx;
            const hingeStartY = startY + sideProgress * unitDy;
            const hingeCenterX = hingeStartX + (hingeLen / 2) * unitDx;
            const hingeCenterY = hingeStartY + (hingeLen / 2) * unitDy;
            
            const hingeCorners = [
              [-hingeLen/2, -halfThick], [hingeLen/2, -halfThick], 
              [hingeLen/2, halfThick], [-hingeLen/2, halfThick]
            ];
            
            const hingeRotatedCorners = hingeCorners.map(([x, y]) => {
              const cos = Math.cos(angle * Math.PI / 180);
              const sin = Math.sin(angle * Math.PI / 180);
              return [
                hingeCenterX + (x * cos - y * sin),
                hingeCenterY + (x * sin + y * cos)
              ];
            });
            
            const hingePanel = document.createElementNS(NS,'polygon');
            hingePanel.setAttribute('points', hingeRotatedCorners.map(p => p.join(',')).join(' '));
            hingePanel.setAttribute('fill', '#ffcccc');
            hingePanel.setAttribute('stroke', '#cc9999');
            hingePanel.setAttribute('stroke-width', '0.25');
            svg.appendChild(hingePanel);
            
            sideProgress += hingeLen;
          }
        } else if (panelIndex < lay.panelWidths.length - 1) {
          // Add normal gap space only if no gate
          sideProgress += lay.gap * PX;
        }
      });
    });

    // LAYER 3: Blue panel length labels (on top of red lines)
    layouts.forEach((lay,i)=>{
      const run = customRuns[i];
      const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
      const unitDx = run.dx / length;
      const unitDy = run.dy / length;
      
      let currentX = 0, currentY = 0;
      for (let j = 0; j < i; j++) {
        currentX += customRuns[j].dx * PX;
        currentY += customRuns[j].dy * PX;
      }
      
      const normalX = -unitDy;
      const normalY = unitDx;
      const insetX = normalX * INSET;
      const insetY = normalY * INSET;
      
      const startX = (currentX - minX) + MAR + insetX;
      const startY = (currentY - minY) + MAR + insetY;
      
      let sideProgress = 0;
      
      // Gate detection logic (same as panel rendering)
      let gatePanelIndex = null;
      if (lay.gateSegment) {
        if (lay.gateSegment.panelIndex !== undefined) {
          gatePanelIndex = lay.gateSegment.panelIndex;
        } else {
          const totalPanels = lay.panelWidths.length;
          const position = lay.gateSegment.position || 'middle';
          if (position === 'left') {
            gatePanelIndex = Math.floor(totalPanels * 0.25);
          } else if (position === 'right') {
            gatePanelIndex = Math.floor(totalPanels * 0.75);
          } else {
            gatePanelIndex = Math.floor(totalPanels / 2);
          }
        }
      }
      
      lay.panelWidths.forEach((pw, panelIndex) => {
        const panelLen = pw * PX;
        
        // Calculate panel center position
        const panelMidX = startX + (sideProgress + panelLen/2) * unitDx;
        const panelMidY = startY + (sideProgress + panelLen/2) * unitDy;
        
        // Position label well inside the fence area (further from panel edges)
        const labelOffsetInward = INSET + LABEL_OFFSET + 8; // Much larger inward offset to move away from panel edges
        const labelX = panelMidX - normalX * labelOffsetInward; // Negative for inward
        const labelY = panelMidY - normalY * labelOffsetInward; // Negative for inward
        
        // Panel length label with proper orientation
        const t = document.createElementNS(NS,'text');
        t.textContent = `${Math.round(pw)} mm`;
        t.setAttribute('font-size', String(PANEL_FONT));
        t.setAttribute('font-weight', 'bold');
        t.setAttribute('fill', 'rgb(20,80,160)');
        t.setAttribute('text-anchor', 'middle');
        t.setAttribute('dominant-baseline', 'middle');
        
        // Keep text upright: flip if it would be upside-down
        const angle = Math.atan2(unitDy, unitDx) * 180 / Math.PI;
        const normalizedAngle = (angle + 360) % 360;
        const finalAngle = (normalizedAngle > 90 && normalizedAngle < 270) ? angle + 180 : angle;
        
        t.setAttribute('x', labelX);
        t.setAttribute('y', labelY);
        t.setAttribute('transform', `rotate(${finalAngle} ${labelX} ${labelY})`);
        svg.appendChild(t);

        sideProgress += panelLen;
        
        // Gate handling: add gate segment labels and spacing
        if (lay.gateSegment && panelIndex === gatePanelIndex && panelIndex < lay.panelWidths.length - 1) {
          const hingeOnLeft = lay.gateSegment.hingeOnLeft !== undefined ? lay.gateSegment.hingeOnLeft : false;
          
          if (hingeOnLeft) {
            // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
            // 5mm hinge label
            const hingeLen = 5 * PX;
            const hingeMidX = startX + (sideProgress + hingeLen/2) * unitDx;
            const hingeMidY = startY + (sideProgress + hingeLen/2) * unitDy;
            const hingeLabelX = hingeMidX - normalX * labelOffsetInward;
            const hingeLabelY = hingeMidY - normalY * labelOffsetInward;
            
            const hingeLabel = document.createElementNS(NS,'text');
            hingeLabel.textContent = '5mm H';
            hingeLabel.setAttribute('font-size', String(GAP_FONT));
            hingeLabel.setAttribute('font-weight', 'bold');
            hingeLabel.setAttribute('fill', '#cc6666');
            hingeLabel.setAttribute('text-anchor', 'middle');
            hingeLabel.setAttribute('dominant-baseline', 'middle');
            hingeLabel.setAttribute('x', hingeLabelX);
            hingeLabel.setAttribute('y', hingeLabelY);
            hingeLabel.setAttribute('transform', `rotate(${finalAngle} ${hingeLabelX} ${hingeLabelY})`);
            svg.appendChild(hingeLabel);
            
            sideProgress += hingeLen;
            
            // 890mm gate label
            const gateLen = 890 * PX;
            const gateMidX = startX + (sideProgress + gateLen/2) * unitDx;
            const gateMidY = startY + (sideProgress + gateLen/2) * unitDy;
            const gateLabelX = gateMidX - normalX * labelOffsetInward;
            const gateLabelY = gateMidY - normalY * labelOffsetInward;
            
            const gateLabel = document.createElementNS(NS,'text');
            gateLabel.textContent = '890mm GATE';
            gateLabel.setAttribute('font-size', String(PANEL_FONT));
            gateLabel.setAttribute('font-weight', 'bold');
            gateLabel.setAttribute('fill', '#006600');
            gateLabel.setAttribute('text-anchor', 'middle');
            gateLabel.setAttribute('dominant-baseline', 'middle');
            gateLabel.setAttribute('x', gateLabelX);
            gateLabel.setAttribute('y', gateLabelY);
            gateLabel.setAttribute('transform', `rotate(${finalAngle} ${gateLabelX} ${gateLabelY})`);
            svg.appendChild(gateLabel);
            
            sideProgress += gateLen;
            
            // 10mm latch label
            const latchLen = 10 * PX;
            const latchMidX = startX + (sideProgress + latchLen/2) * unitDx;
            const latchMidY = startY + (sideProgress + latchLen/2) * unitDy;
            const latchLabelX = latchMidX - normalX * labelOffsetInward;
            const latchLabelY = latchMidY - normalY * labelOffsetInward;
            
            const latchLabel = document.createElementNS(NS,'text');
            latchLabel.textContent = '10mm L';
            latchLabel.setAttribute('font-size', String(GAP_FONT));
            latchLabel.setAttribute('font-weight', 'bold');
            latchLabel.setAttribute('fill', '#339933');
            latchLabel.setAttribute('text-anchor', 'middle');
            latchLabel.setAttribute('dominant-baseline', 'middle');
            latchLabel.setAttribute('x', latchLabelX);
            latchLabel.setAttribute('y', latchLabelY);
            latchLabel.setAttribute('transform', `rotate(${finalAngle} ${latchLabelX} ${latchLabelY})`);
            svg.appendChild(latchLabel);
            
            sideProgress += latchLen;
          } else {
            // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
            // 10mm latch label
            const latchLen = 10 * PX;
            const latchMidX = startX + (sideProgress + latchLen/2) * unitDx;
            const latchMidY = startY + (sideProgress + latchLen/2) * unitDy;
            const latchLabelX = latchMidX - normalX * labelOffsetInward;
            const latchLabelY = latchMidY - normalY * labelOffsetInward;
            
            const latchLabel = document.createElementNS(NS,'text');
            latchLabel.textContent = '10mm L';
            latchLabel.setAttribute('font-size', String(GAP_FONT));
            latchLabel.setAttribute('font-weight', 'bold');
            latchLabel.setAttribute('fill', '#339933');
            latchLabel.setAttribute('text-anchor', 'middle');
            latchLabel.setAttribute('dominant-baseline', 'middle');
            latchLabel.setAttribute('x', latchLabelX);
            latchLabel.setAttribute('y', latchLabelY);
            latchLabel.setAttribute('transform', `rotate(${finalAngle} ${latchLabelX} ${latchLabelY})`);
            svg.appendChild(latchLabel);
            
            sideProgress += latchLen;
            
            // 890mm gate label
            const gateLen = 890 * PX;
            const gateMidX = startX + (sideProgress + gateLen/2) * unitDx;
            const gateMidY = startY + (sideProgress + gateLen/2) * unitDy;
            const gateLabelX = gateMidX - normalX * labelOffsetInward;
            const gateLabelY = gateMidY - normalY * labelOffsetInward;
            
            const gateLabel = document.createElementNS(NS,'text');
            gateLabel.textContent = '890mm GATE';
            gateLabel.setAttribute('font-size', String(PANEL_FONT));
            gateLabel.setAttribute('font-weight', 'bold');
            gateLabel.setAttribute('fill', '#006600');
            gateLabel.setAttribute('text-anchor', 'middle');
            gateLabel.setAttribute('dominant-baseline', 'middle');
            gateLabel.setAttribute('x', gateLabelX);
            gateLabel.setAttribute('y', gateLabelY);
            gateLabel.setAttribute('transform', `rotate(${finalAngle} ${gateLabelX} ${gateLabelY})`);
            svg.appendChild(gateLabel);
            
            sideProgress += gateLen;
            
            // 5mm hinge label
            const hingeLen = 5 * PX;
            const hingeMidX = startX + (sideProgress + hingeLen/2) * unitDx;
            const hingeMidY = startY + (sideProgress + hingeLen/2) * unitDy;
            const hingeLabelX = hingeMidX - normalX * labelOffsetInward;
            const hingeLabelY = hingeMidY - normalY * labelOffsetInward;
            
            const hingeLabel = document.createElementNS(NS,'text');
            hingeLabel.textContent = '5mm H';
            hingeLabel.setAttribute('font-size', String(GAP_FONT));
            hingeLabel.setAttribute('font-weight', 'bold');
            hingeLabel.setAttribute('fill', '#cc6666');
            hingeLabel.setAttribute('text-anchor', 'middle');
            hingeLabel.setAttribute('dominant-baseline', 'middle');
            hingeLabel.setAttribute('x', hingeLabelX);
            hingeLabel.setAttribute('y', hingeLabelY);
            hingeLabel.setAttribute('transform', `rotate(${finalAngle} ${hingeLabelX} ${hingeLabelY})`);
            svg.appendChild(hingeLabel);
            
            sideProgress += hingeLen;
          }
        } else if (panelIndex < lay.panelWidths.length - 1) {
          sideProgress += lay.gap * PX;
        }
      });
    });

    // LAYER 4: Gray gap labels (topmost)
    layouts.forEach((lay,i)=>{
      const run = customRuns[i];
      const length = Math.sqrt(run.dx * run.dx + run.dy * run.dy);
      const unitDx = run.dx / length;
      const unitDy = run.dy / length;
      
      let currentX = 0, currentY = 0;
      for (let j = 0; j < i; j++) {
        currentX += customRuns[j].dx * PX;
        currentY += customRuns[j].dy * PX;
      }
      
      const normalX = -unitDy;
      const normalY = unitDx;
      const insetX = normalX * INSET;
      const insetY = normalY * INSET;
      
      const startX = (currentX - minX) + MAR + insetX;
      const startY = (currentY - minY) + MAR + insetY;
      
      let sideProgress = 0;
      
      lay.panelWidths.forEach((pw, panelIndex) => {
        sideProgress += pw * PX;
        
        if (panelIndex < lay.panelWidths.length - 1) {
          const gapLen = lay.gap * PX;
          
          // Calculate gap center position
          const gapMidX = startX + (sideProgress + gapLen/2) * unitDx;
          const gapMidY = startY + (sideProgress + gapLen/2) * unitDy;
          
          // Position gap label further away from glass (beyond red arrows)
          const labelOffsetTotal = INSET + LABEL_OFFSET;
          const gapLabelX = gapMidX + normalX * labelOffsetTotal;
          const gapLabelY = gapMidY + normalY * labelOffsetTotal;
          
          const gapText = document.createElementNS(NS,'text');
          gapText.textContent = `${Math.round(lay.gap)} mm`;
          gapText.setAttribute('font-size', String(GAP_FONT));
          gapText.setAttribute('font-weight', 'bold');
          gapText.setAttribute('fill', 'rgb(90,90,90)');
          gapText.setAttribute('text-anchor', 'middle');
          gapText.setAttribute('dominant-baseline', 'middle');
          
          // Keep text upright: flip if it would be upside-down
          const angle = Math.atan2(unitDy, unitDx) * 180 / Math.PI;
          const normalizedAngle = (angle + 360) % 360;
          const finalAngle = (normalizedAngle > 90 && normalizedAngle < 270) ? angle + 180 : angle;
          
          gapText.setAttribute('x', gapLabelX);
          gapText.setAttribute('y', gapLabelY);
          gapText.setAttribute('transform', `rotate(${finalAngle} ${gapLabelX} ${gapLabelY})`);
          svg.appendChild(gapText);
          
          sideProgress += gapLen;
        }
      });
    });

    return svg.outerHTML;
  }

  // PNG preview
document.getElementById('pdfBtn').onclick = async () => {
  try {
    if (!layouts.length) {
      alert('Please calculate first');
      return;
    }
    
    // Check if this is a custom shape and use appropriate plan generation
    let svg;
    if (window.customShapeData && window.customShapeData.isCustom && curShape && curShape.id === 'CUSTOM') {
      const svgString = buildCustomPlanSVG(layouts, window.customShapeData.runs);
      // Convert string to DOM element for XMLSerializer
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgString, 'image/svg+xml');
      svg = doc.documentElement;
    } else {
      svg = buildPlanSVG(layouts, sideLens);
    }
    
    if (!svg) {
      alert('Could not generate plan SVG');
      return;
    }
    const uri = 'data:image/svg+xml;base64,' + btoa(new XMLSerializer().serializeToString(svg));
    const png = await new Promise((res, rej) => {
      const img = new Image();
      img.onload = () => {
        const scale = 1.5;
        const c = document.createElement('canvas');
        c.width = img.width * scale;
        c.height = img.height * scale;
        const ctx = c.getContext('2d');
        ctx.setTransform(scale, 0, 0, scale, 0, 0);
        ctx.drawImage(img, 0, 0);
        res(c.toDataURL('image/png'));
      };
      img.onerror = () => {
        alert('Failed to load plan image');
        rej();
      };
      img.src = uri;
    });

    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    // Accent bar
    const barWidth = pageWidth - 240;
    const barHeight = 48;
    const barX = (pageWidth - barWidth) / 2;
    const barY = 0;
    const barRadius = 24;

    pdf.setFillColor(0, 0, 0);
    pdf.roundedRect(barX, barY, barWidth, barHeight, barRadius, barRadius, 'F');

    // Title
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(22);
    pdf.text('Opus Hardware – Glass Fence Plan', pageWidth / 2, barY + 32, { align: 'center' });

    // Info box
    pdf.setFontSize(13);
    pdf.setTextColor(17, 17, 17);
    pdf.setFont('helvetica', 'normal');
    pdf.setDrawColor(234, 234, 234);
    pdf.setFillColor(255, 255, 255);
    pdf.roundedRect(40, 55, pageWidth - 80, 60, 10, 10, 'FD');
    pdf.text(`Shape: ${curShape.label}`, 60, 80);
    pdf.text(`Total Run: ${sideLens.reduce((a, b) => a + b, 0)} mm`, 60, 100);

    // Plan image
    const img2 = new Image();
    img2.src = png;
    img2.onload = () => {
      const marginX = 40, marginY = 130;
      const maxImgWidth = pageWidth - marginX * 2;
      const maxImgHeight = pageHeight - marginY - 60;
      const scale = Math.min(maxImgWidth / img2.width, maxImgHeight / img2.height, 1);
      const imgWidth = img2.width * scale;
      const imgHeight = img2.height * scale;
      const imgX = (pageWidth - imgWidth) / 2;
      const imgY = marginY + ((maxImgHeight - imgHeight) / 2);

      pdf.setDrawColor(234, 234, 234);
      pdf.setFillColor(255, 255, 255);
      pdf.roundedRect(imgX - 10, imgY - 10, imgWidth + 20, imgHeight + 20, 16, 16, 'FD');
      pdf.addImage(img2, 'PNG', imgX, imgY, imgWidth, imgHeight);

      // Footer text
      pdf.setFontSize(10);
      pdf.setTextColor(120, 120, 120);
      pdf.text('Generated by Opus Hardware Glass Designer', 40, pageHeight - 24);

      // --- Add logo in bottom right ---
      const logoUrl = "https://cdn.shopify.com/s/files/1/0663/2738/0132/files/logomark_3eb73790-7aec-4bc9-ad74-0440d7517010.png?v=1729231583";
      const logoImg = new Image();
      logoImg.crossOrigin = "Anonymous";
      logoImg.src = logoUrl;

      logoImg.onload = () => {
const logoWidth = 60;   // wider
const logoHeight = 36;  // keep aspect ratio
const logoX = pageWidth - logoWidth - 32;
const logoY = pageHeight - logoHeight - 24;

pdf.addImage(logoImg, 'PNG', logoX, logoY, logoWidth, logoHeight);

        pdf.save('Opus_GlassPlan.pdf');
      };
      logoImg.onerror = () => {
        alert('Failed to load Opus logo for PDF');
        pdf.save('Opus_GlassPlan.pdf'); // Save anyway if logo fails
      };
    };
    img2.onerror = () => alert('Failed to load PNG for PDF');
  } catch (e) {
    alert('PDF generation failed: ' + e);
  }
};

// --- 3D View Generation ---
document.getElementById('view3dBtn').onclick = () => {
  try {
    if (!layouts.length) {
      alert('Please calculate first');
      return;
    }

    // Calculate fence geometry points using actual direction vectors
    let pts = [[0,0]];
    let x = 0, y = 0;
    
    if (window.customShapeData && window.customShapeData.isCustom) {
      // Use actual direction vectors from custom shape
      const customRuns = window.customShapeData.runs;
      const scale = 1; // Keep in mm for 3D
      customRuns.forEach((run, i) => {
        x += run.dx;
        y += run.dy;
        pts.push([x, y]);
      });
    } else {
      // Use default orthogonal directions for standard shapes
      const dirs = [[1,0],[0,1],[-1,0],[0,-1]];
      sideLens.forEach((l, i) => {
        x += dirs[i % 4][0] * l;
        y += dirs[i % 4][1] * l;
        pts.push([x, y]);
      });
    }

    // Prepare 3D view data with correct fence geometry
    const sideCount = pts.length - 1;const runsAligned = [];for (let i = 0; i < sideCount; i++) {  const L = layouts[i];  if (L && Array.isArray(L.panelWidths)) { runsAligned.push(L); }  else {    const segLen = Math.hypot(pts[i+1][0]-pts[i][0], pts[i+1][1]-pts[i][1]);    runsAligned.push({ panelWidths: [], gap: 0, run: segLen, missing: true });  }}const fence = $('fenceType').value;const pool = fence === 'pool';const thk = $('glassThk').value;const ht = $('glassHt').value;const zone = $('windZone').value;let __maxSpacing = 400;if (pool) { __maxSpacing = 400; }else if (PS1 && PS1.balustrade && PS1.balustrade.internal[thk] && PS1.balustrade.internal[thk][ht]) {__maxSpacing = PS1.balustrade.internal[thk][ht][zone] || 400;}const __limit4 = $('limit4Discs') ? $('limit4Discs').checked : false;const __maxDiscsPerPanel = __limit4 ? 4 : Infinity;const __edgeMax = 200;const view3dData = { runs: runsAligned, pts: pts, sideLens: sideLens, curShape: curShape, handrailType: $('handrailType').value, finishType: $('finishType').value, maxSpacing: __maxSpacing, edgeMax: __edgeMax, maxDiscsPerPanel: __maxDiscsPerPanel, pool: pool, thk: thk, ht: ht, zone: zone };

    // Create the 3D view HTML
    const html3d = generate3DViewHTML(view3dData);
    
    // Open in new window
    const newWindow = window.open('', '_blank', 'width=1200,height=800');
    newWindow.document.write(html3d);
    newWindow.document.close();
    
  } catch (e) {
    alert('3D view generation failed: ' + e);
  }
};

function generate3DViewHTML(data) {
  var html = '<!DOCTYPE html><html><head><title>3D Fence Plan View</title>';
  html += '<style>body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #f0f0f0; }</style>';
  html += '<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>';
  html += '<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"><\/script>';
  html += '</head><body>';
  html += '<div style="position: absolute; top: 10px; left: 10px; color: #333; z-index: 100; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 5px;">';
  html += '<strong>3D Fence Plan View</strong><br>Mouse: Orbit | Wheel: Zoom | Right-click: Pan</div>';
  html += '<div style="position: absolute; top: 10px; right: 10px; z-index: 100;">';
  html += '<button onclick="resetCamera()" style="padding: 8px 12px; margin: 2px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; background: #0077c8; color: white;">Reset View</button>';
  html += '<button onclick="window.close()" style="padding: 8px 12px; margin: 2px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; background: #0077c8; color: white;">Close</button>';
  html += '</div>';
  
  html += '<script>';
  html += 'const layoutData = ' + JSON.stringify(data) + ';';
  html += 'const scene = new THREE.Scene();';
  html += 'scene.background = new THREE.Color(0xf0f0f0);';
  html += 'const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);';
  html += 'const renderer = new THREE.WebGLRenderer({ antialias: true });renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));';
  html += 'renderer.setSize(window.innerWidth, window.innerHeight);';
  html += 'document.body.appendChild(renderer.domElement);function onWindowResize(){camera.aspect = window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth, window.innerHeight);}window.addEventListener("resize", onWindowResize);';
  html += 'const controls = new THREE.OrbitControls(camera, renderer.domElement);';
  html += 'camera.position.set(5, 4, 5);';
  html += 'controls.target.set(0, 0, 0);controls.enableDamping = true;controls.dampingFactor = 0.08;controls.minDistance = 1.5;controls.maxDistance = 50;controls.maxPolarAngle = Math.PI * 0.49;controls.minPolarAngle = Math.PI * 0.05;';
  html += 'const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);';
  html += 'scene.add(ambientLight);';
  
  html += 'function createCustomGround() {';
  html += 'if (!layoutData || !layoutData.pts || layoutData.pts.length === 0) return;';
  html += 'const pts = layoutData.pts;';
  html += 'if (pts.length < 3) return;';
  html += 'const scale = 0.002;';
  html += 'try {';
  html += 'const scaledPoints = pts.map(pt => new THREE.Vector2(pt[0] * scale, -pt[1] * scale));';
  html += 'const area = scaledPoints.reduce((a, p, i) => {';
  html += 'const q = scaledPoints[(i + 1) % scaledPoints.length];';
  html += 'return a + (p.x * q.y - q.x * p.y);';
  html += '}, 0);';
  html += 'if (area < 0) scaledPoints.reverse();';
  html += 'const shape = new THREE.Shape(scaledPoints);';
  html += 'const groundGeometry = new THREE.ShapeGeometry(shape);';
  html += 'groundGeometry.rotateX(-Math.PI / 2);';
  html += 'groundGeometry.translate(0, 0.001, 0);';
  html += 'const groundMaterial = new THREE.MeshStandardMaterial({';
  html += 'color: 0xaaaaaa,';
  html += 'roughness: 0.85,';
  html += 'metalness: 0,';
  html += 'transparent: true,';
  html += 'opacity: 0.7,';
  html += 'side: THREE.DoubleSide';
  html += '});';
  html += 'const ground = new THREE.Mesh(groundGeometry, groundMaterial);';
  html += 'if (window.floorMesh) {';
  html += 'scene.remove(window.floorMesh);';
  html += 'window.floorMesh.geometry.dispose();';
  html += 'window.floorMesh.material.dispose();';
  html += '}';
  html += 'scene.add(ground);';
  html += 'window.floorMesh = ground;';
  html += '} catch (e) {';
  html += 'console.warn("Floor creation failed:", e);';
  html += '}';
  html += '}';
  html += 'createCustomGround();';
  
  html += 'function createFence3D() {';
  html += 'function faceOutward(mesh, startPt, endPt) {';
  html += 'const normal = new THREE.Vector3(endPt[1] - startPt[1], 0, -(endPt[0] - startPt[0])).normalize();';
  html += 'mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), normal);';
  html += '}';
  html += 'const BOTTOM_OFFSET = 0.08;';
  html += 'const ROW_SPACING = 0.16;';
  html += 'const runs = layoutData.runs || [];';
  html += 'const pts = layoutData.pts || [];';
  html += 'if (runs.length === 0 || pts.length === 0) { console.warn("No fence data"); return; }';
  html += 'console.log("3D Data:", { runs: runs, pts: pts });';
  html += 'runs.forEach((layout, sideIndex) => {';
  html += 'if (!pts[sideIndex] || !pts[sideIndex + 1]) return;';
  html += 'const startPt = pts[sideIndex];';
  html += 'const endPt = pts[sideIndex + 1];';
  html += 'const dx = endPt[0] - startPt[0];';
  html += 'const dy = endPt[1] - startPt[1];';
  html += 'const scale = 0.002;';
  html += 'let currentPos = 0;';
  html += 'if (!layout.panelWidths || !layout.panelWidths.length) { /* side has no solution, skip drawing panels but keep index */ return; }';
  html += 'let gatePanelIndex = null;';
  html += 'if (layout.gateSegment) {';
  html += 'if (layout.gateSegment.panelIndex !== undefined) {';
  html += 'gatePanelIndex = layout.gateSegment.panelIndex;';
  html += '} else {';
  html += 'const totalPanels = layout.panelWidths.length;';
  html += 'const position = layout.gateSegment.position || "middle";';
  html += 'if (position === "left") {';
  html += 'gatePanelIndex = Math.floor(totalPanels * 0.25);';
  html += '} else if (position === "right") {';
  html += 'gatePanelIndex = Math.floor(totalPanels * 0.75);';
  html += '} else {';
  html += 'gatePanelIndex = Math.floor(totalPanels / 2);';
  html += '}';
  html += '}';
  html += '}';
  html += 'layout.panelWidths.forEach((panelWidth, panelIndex) => {';
  html += 'const panelLength = panelWidth * scale;';
  html += 'const panelHeight = 2.4;';
  html += 'const geometry = new THREE.BoxGeometry(panelLength, panelHeight, 0.024);';
  html += 'const material = new THREE.MeshLambertMaterial({ color: 0x88ccee, transparent: true, opacity: 0.7 });';
  html += 'const panel = new THREE.Mesh(geometry, material);';
  html += 'const sideLength = Math.sqrt(dx * dx + dy * dy);';
  html += 'const progress = (currentPos + panelLength / 2) / (sideLength * scale);';
  html += 'const x = startPt[0] * scale + dx * scale * progress;';
  html += 'const z = startPt[1] * scale + dy * scale * progress;';
  html += 'panel.position.set(x, panelHeight / 2, z);';
  html += 'const angle = Math.atan2(dy, dx);';
  html += 'panel.rotation.y = -angle;';
  html += 'scene.add(panel);';
  // Insert channel bar under each panel (150mm high, 50mm thick) and advance current position
  html += 'const chHeight=0.15;';
  html += 'const chThickness=0.05;';
  html += 'const channelGeometry=new THREE.BoxGeometry(panelLength,chHeight,chThickness);';
  html += 'const channelMaterial=new THREE.MeshStandardMaterial({ color:0x999999, metalness:0.8, roughness:0.2 });';
  html += 'const channel=new THREE.Mesh(channelGeometry,channelMaterial);';
  html += 'channel.position.set(x,chHeight/2,z);';
  html += 'channel.rotation.y=-angle;';
  html += 'scene.add(channel);';
  html += 'currentPos += panelLength;';
  
  // Check if this is the gate position and add gate geometry in the gap
  html += 'if (layout.gateSegment && panelIndex === gatePanelIndex && panelIndex < layout.panelWidths.length - 1) {';
  html += 'let gateCurrentPos = currentPos;';
  html += 'const hingeOnLeft = layout.gateSegment.hingeOnLeft !== undefined ? layout.gateSegment.hingeOnLeft : false;';
  html += 'if (hingeOnLeft) {';
  // Layout: hinge(5mm) → gate(890mm) → latch(10mm)
  // 5mm hinge (light red) - positioned at start of gap
  html += 'const hingeProgress = (gateCurrentPos + 2.5 * scale) / (sideLength * scale);';
  html += 'const hingeX = startPt[0] * scale + dx * scale * hingeProgress;';
  html += 'const hingeZ = startPt[1] * scale + dy * scale * hingeProgress;';
  html += 'const hingeGeometry = new THREE.BoxGeometry(5 * scale, panelHeight, 0.024);';
  html += 'const hingeMaterial = new THREE.MeshLambertMaterial({ color: 0xffcccc, transparent: true, opacity: 0.8 });';
  html += 'const hingePanel = new THREE.Mesh(hingeGeometry, hingeMaterial);';
  html += 'hingePanel.position.set(hingeX, panelHeight / 2, hingeZ);';
  html += 'hingePanel.rotation.y = -angle;';
  html += 'scene.add(hingePanel);';
  html += 'gateCurrentPos += 5 * scale;';
  // 890mm gate (green) - positioned after hinge
  html += 'const gateProgress = (gateCurrentPos + 445 * scale) / (sideLength * scale);';
  html += 'const gateX = startPt[0] * scale + dx * scale * gateProgress;';
  html += 'const gateZ = startPt[1] * scale + dy * scale * gateProgress;';
  html += 'const gateGeometry = new THREE.BoxGeometry(890 * scale, panelHeight, 0.024);';
  html += 'const gateMaterial = new THREE.MeshLambertMaterial({ color: 0x90ee90, transparent: true, opacity: 0.7 });';
  html += 'const gateMainPanel = new THREE.Mesh(gateGeometry, gateMaterial);';
  html += 'gateMainPanel.position.set(gateX, panelHeight / 2, gateZ);';
  html += 'gateMainPanel.rotation.y = -angle;';
  html += 'scene.add(gateMainPanel);';
  html += 'gateCurrentPos += 890 * scale;';
  // 10mm latch (light green) - positioned after gate
  html += 'const latchProgress = (gateCurrentPos + 5 * scale) / (sideLength * scale);';
  html += 'const latchX = startPt[0] * scale + dx * scale * latchProgress;';
  html += 'const latchZ = startPt[1] * scale + dy * scale * latchProgress;';
  html += 'const latchGeometry = new THREE.BoxGeometry(10 * scale, panelHeight, 0.024);';
  html += 'const latchMaterial = new THREE.MeshLambertMaterial({ color: 0xccffcc, transparent: true, opacity: 0.8 });';
  html += 'const latchPanel = new THREE.Mesh(latchGeometry, latchMaterial);';
  html += 'latchPanel.position.set(latchX, panelHeight / 2, latchZ);';
  html += 'latchPanel.rotation.y = -angle;';
  html += 'scene.add(latchPanel);';
  html += '} else {';
  // Layout: latch(10mm) → gate(890mm) → hinge(5mm)
  // 10mm latch (light green) - positioned at start of gap
  html += 'const latchProgress = (gateCurrentPos + 5 * scale) / (sideLength * scale);';
  html += 'const latchX = startPt[0] * scale + dx * scale * latchProgress;';
  html += 'const latchZ = startPt[1] * scale + dy * scale * latchProgress;';
  html += 'const latchGeometry = new THREE.BoxGeometry(10 * scale, panelHeight, 0.024);';
  html += 'const latchMaterial = new THREE.MeshLambertMaterial({ color: 0xccffcc, transparent: true, opacity: 0.8 });';
  html += 'const latchPanel = new THREE.Mesh(latchGeometry, latchMaterial);';
  html += 'latchPanel.position.set(latchX, panelHeight / 2, latchZ);';
  html += 'latchPanel.rotation.y = -angle;';
  html += 'scene.add(latchPanel);';
  html += 'gateCurrentPos += 10 * scale;';
  // 890mm gate (green) - positioned after latch
  html += 'const gateProgress = (gateCurrentPos + 445 * scale) / (sideLength * scale);';
  html += 'const gateX = startPt[0] * scale + dx * scale * gateProgress;';
  html += 'const gateZ = startPt[1] * scale + dy * scale * gateProgress;';
  html += 'const gateGeometry = new THREE.BoxGeometry(890 * scale, panelHeight, 0.024);';
  html += 'const gateMaterial = new THREE.MeshLambertMaterial({ color: 0x90ee90, transparent: true, opacity: 0.7 });';
  html += 'const gateMainPanel = new THREE.Mesh(gateGeometry, gateMaterial);';
  html += 'gateMainPanel.position.set(gateX, panelHeight / 2, gateZ);';
  html += 'gateMainPanel.rotation.y = -angle;';
  html += 'scene.add(gateMainPanel);';
  html += 'gateCurrentPos += 890 * scale;';
  // 5mm hinge (light red) - positioned after gate
  html += 'const hingeProgress = (gateCurrentPos + 2.5 * scale) / (sideLength * scale);';
  html += 'const hingeX = startPt[0] * scale + dx * scale * hingeProgress;';
  html += 'const hingeZ = startPt[1] * scale + dy * scale * hingeProgress;';
  html += 'const hingeGeometry = new THREE.BoxGeometry(5 * scale, panelHeight, 0.024);';
  html += 'const hingeMaterial = new THREE.MeshLambertMaterial({ color: 0xffcccc, transparent: true, opacity: 0.8 });';
  html += 'const hingePanel = new THREE.Mesh(hingeGeometry, hingeMaterial);';
  html += 'hingePanel.position.set(hingeX, panelHeight / 2, hingeZ);';
  html += 'hingePanel.rotation.y = -angle;';
  html += 'scene.add(hingePanel);';
  html += 'gateCurrentPos += 5 * scale;';
  html += '}';
  html += 'currentPos = gateCurrentPos;';
  html += '}';
  
  html += 'const hasGateAtThisPosition = (layout.gateSegment && panelIndex === gatePanelIndex);';
  html += 'if (panelIndex < layout.panelWidths.length - 1 && !hasGateAtThisPosition) {';
  html += 'currentPos += (layout.gap || 8) * scale;';
  html += '}';
  html += '});';
  html += '});';
  html += '}';
  
  html += 'function addDimensionLabels() {';
  html += 'const runs = layoutData.runs || [];';
  html += 'const pts = layoutData.pts || [];';
  html += 'if (runs.length === 0 || pts.length === 0) return;';
  html += 'const scale = 0.002;';
  html += 'const loader = new THREE.FontLoader();';
  html += 'const fontUrl = "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json";';
  html += 'loader.load(fontUrl, function(font) {';
  html += 'runs.forEach((layout, sideIndex) => {';
  html += 'if (!pts[sideIndex] || !pts[sideIndex + 1]) return;';
  html += 'const startPt = pts[sideIndex];';
  html += 'const endPt = pts[sideIndex + 1];';
  html += 'const dx = endPt[0] - startPt[0];';
  html += 'const dy = endPt[1] - startPt[1];';
  html += 'const sideLength = Math.sqrt(dx * dx + dy * dy);';
  html += 'const midX = (startPt[0] + endPt[0]) / 2 * scale;';
  html += 'const midZ = (startPt[1] + endPt[1]) / 2 * scale;';
  html += 'const runLengthText = Math.round(sideLength) + "mm";';html += 'const textGeometry = new THREE.TextGeometry(runLengthText, {';html += 'font: font,';html += 'size: 0.15,';html += 'height: 0.02,';html += 'curveSegments: 12,';html += 'bevelEnabled: true,';html += 'bevelThickness: 0.005,';html += 'bevelSize: 0.002,';html += 'bevelSegments: 3';html += '});';html += 'textGeometry.computeBoundingBox();';html += 'if (textGeometry.center) { textGeometry.center(); } else { const bb2=textGeometry.boundingBox; const xMid2=(bb2.max.x+bb2.min.x)/2; textGeometry.translate(-xMid2,0,0); }';html += 'const textMaterial = new THREE.MeshPhongMaterial({ ';
  html += 'color: 0x000000,';
  html += 'shininess: 30,';
  html += 'specular: 0x444444';
  html += '});';
  html += 'const textMesh = new THREE.Mesh(textGeometry, textMaterial);';
  html += 'const textBBox = textGeometry.boundingBox;';
  html += 'const textWidth = textBBox.max.x - textBBox.min.x;';
  html += 'const textHeight = textBBox.max.y - textBBox.min.y;';
  html += 'textMesh.position.set(midX, 2.6, midZ);';
  html += 'const angle = Math.atan2(dy, dx);';
  html += 'textMesh.rotation.y = -angle + Math.PI;';
  
  html += 'const padding = 0.05;';
  html += 'const bgGeometry = new THREE.PlaneGeometry(textWidth + padding * 2, textHeight + padding * 2);';
  html += 'const bgMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 });';
  html += 'const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);';
  html += 'bgMesh.position.set(midX, 2.6, midZ);';
  html += 'bgMesh.rotation.copy(textMesh.rotation);';
  html += 'bgMesh.rotation.z = Math.PI;';
  html += 'scene.add(bgMesh);';
  html += 'scene.add(textMesh);';
  html += 'let currentPos = 0;';
  html += 'let gatePanelIndex = null;';
  html += 'if (layout.gateSegment) {';
  html += 'if (layout.gateSegment.panelIndex !== undefined) {';
  html += 'gatePanelIndex = layout.gateSegment.panelIndex;';
  html += '} else {';
  html += 'const totalPanels = layout.panelWidths.length;';
  html += 'const position = layout.gateSegment.position || "middle";';
  html += 'if (position === "left") {';
  html += 'gatePanelIndex = Math.floor(totalPanels * 0.25);';
  html += '} else if (position === "right") {';
  html += 'gatePanelIndex = Math.floor(totalPanels * 0.75);';
  html += '} else {';
  html += 'gatePanelIndex = Math.floor(totalPanels / 2);';
  html += '}';
  html += '}';
  html += '}';
  html += 'layout.panelWidths.forEach((panelWidth, panelIndex) => {';
  html += 'const panelLength = panelWidth * scale;';
  html += 'const progress = (currentPos + panelLength / 2) / (sideLength * scale);';
  html += 'const panelMidX = startPt[0] * scale + dx * scale * progress;';
  html += 'const panelMidZ = startPt[1] * scale + dy * scale * progress;';
  html += 'const panelText = panelWidth + "mm";';html += 'const panelTextGeometry = new THREE.TextGeometry(panelText, {';html += 'font: font, size: 0.15, height: 0.02';html += '});';html += 'const panelTextMaterial = new THREE.MeshBasicMaterial({ color: 0x0066cc });';html += 'const panelTextMesh = new THREE.Mesh(panelTextGeometry, panelTextMaterial);';html += 'panelTextGeometry.computeBoundingBox();';html += 'if (panelTextGeometry.center) { panelTextGeometry.center(); } else { const bb=panelTextGeometry.boundingBox; const xMid=(bb.max.x+bb.min.x)/2; panelTextGeometry.translate(-xMid,0,0); }';html += 'const normalX = Math.sin(-angle);';html += 'const normalZ = Math.cos(-angle);';html += 'panelTextMesh.position.set(panelMidX - normalX * 0.5, 1.5, panelMidZ - normalZ * 0.5);';html += 'panelTextMesh.rotation.y = -angle + Math.PI;';html += 'scene.add(panelTextMesh);';
  html += 'currentPos += panelLength;';
  html += 'if (layout.gateSegment && panelIndex === gatePanelIndex && panelIndex < layout.panelWidths.length - 1) {';
  html += 'let gateCurrentPos = currentPos;';
  html += 'const hingeOnLeft = layout.gateSegment.hingeOnLeft !== undefined ? layout.gateSegment.hingeOnLeft : false;';
  html += 'if (hingeOnLeft) {';
  // Add hinge label (5mm)
  html += 'const hingeProgress = (gateCurrentPos + 2.5 * scale) / (sideLength * scale);';
  html += 'const hingeLabelX = startPt[0] * scale + dx * scale * hingeProgress;';
  html += 'const hingeLabelZ = startPt[1] * scale + dy * scale * hingeProgress;';
  html += 'const hingeTextGeometry = new THREE.TextGeometry("5mm H", {';
  html += 'font: font, size: 0.03, height: 0.01';
  html += '});';
  html += 'const hingeTextMaterial = new THREE.MeshBasicMaterial({ color: 0xff6666 });';
  html += 'const hingeTextMesh = new THREE.Mesh(hingeTextGeometry, hingeTextMaterial);';
  html += 'hingeTextGeometry.computeBoundingBox();';
  html += 'const hingeTextWidth = hingeTextGeometry.boundingBox.max.x - hingeTextGeometry.boundingBox.min.x;';
  html += 'const hingeOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const hingeOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'hingeTextMesh.position.set(hingeLabelX - hingeTextWidth/2 + hingeOffsetX, 1.0, hingeLabelZ + hingeOffsetZ);';
  html += 'hingeTextMesh.rotation.y = -angle;';
  html += 'scene.add(hingeTextMesh);';
  html += 'gateCurrentPos += 5 * scale;';
  // Add gate label (890mm)
  html += 'const gateProgress = (gateCurrentPos + 445 * scale) / (sideLength * scale);';
  html += 'const gateLabelX = startPt[0] * scale + dx * scale * gateProgress;';
  html += 'const gateLabelZ = startPt[1] * scale + dy * scale * gateProgress;';
  html += 'const gateTextGeometry = new THREE.TextGeometry("890mm GATE", {';
  html += 'font: font, size: 0.05, height: 0.01';
  html += '});';
  html += 'const gateTextMaterial = new THREE.MeshBasicMaterial({ color: 0x00aa00 });';
  html += 'const gateTextMesh = new THREE.Mesh(gateTextGeometry, gateTextMaterial);';
  html += 'gateTextGeometry.computeBoundingBox();';
  html += 'const gateTextWidth = gateTextGeometry.boundingBox.max.x - gateTextGeometry.boundingBox.min.x;';
  html += 'const gateOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const gateOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'gateTextMesh.position.set(gateLabelX - gateTextWidth/2 + gateOffsetX, 1.0, gateLabelZ + gateOffsetZ);';
  html += 'gateTextMesh.rotation.y = -angle;';
  html += 'scene.add(gateTextMesh);';
  html += 'gateCurrentPos += 890 * scale;';
  // Add latch label (10mm)
  html += 'const latchProgress = (gateCurrentPos + 5 * scale) / (sideLength * scale);';
  html += 'const latchLabelX = startPt[0] * scale + dx * scale * latchProgress;';
  html += 'const latchLabelZ = startPt[1] * scale + dy * scale * latchProgress;';
  html += 'const latchTextGeometry = new THREE.TextGeometry("10mm L", {';
  html += 'font: font, size: 0.03, height: 0.01';
  html += '});';
  html += 'const latchTextMaterial = new THREE.MeshBasicMaterial({ color: 0x66ff66 });';
  html += 'const latchTextMesh = new THREE.Mesh(latchTextGeometry, latchTextMaterial);';
  html += 'latchTextGeometry.computeBoundingBox();';
  html += 'const latchTextWidth = latchTextGeometry.boundingBox.max.x - latchTextGeometry.boundingBox.min.x;';
  html += 'const latchOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const latchOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'latchTextMesh.position.set(latchLabelX - latchTextWidth/2 + latchOffsetX, 1.0, latchLabelZ + latchOffsetZ);';
  html += 'latchTextMesh.rotation.y = -angle;';
  html += 'scene.add(latchTextMesh);';
  html += 'gateCurrentPos += 10 * scale;';
  html += '} else {';
  // Reverse order: latch → gate → hinge
  // Add latch label (10mm)
  html += 'const latchProgress = (gateCurrentPos + 5 * scale) / (sideLength * scale);';
  html += 'const latchLabelX = startPt[0] * scale + dx * scale * latchProgress;';
  html += 'const latchLabelZ = startPt[1] * scale + dy * scale * latchProgress;';
  html += 'const latchTextGeometry = new THREE.TextGeometry("10mm L", {';
  html += 'font: font, size: 0.03, height: 0.01';
  html += '});';
  html += 'const latchTextMaterial = new THREE.MeshBasicMaterial({ color: 0x66ff66 });';
  html += 'const latchTextMesh = new THREE.Mesh(latchTextGeometry, latchTextMaterial);';
  html += 'latchTextGeometry.computeBoundingBox();';
  html += 'const latchTextWidth = latchTextGeometry.boundingBox.max.x - latchTextGeometry.boundingBox.min.x;';
  html += 'const latchOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const latchOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'latchTextMesh.position.set(latchLabelX - latchTextWidth/2 + latchOffsetX, 1.0, latchLabelZ + latchOffsetZ);';
  html += 'latchTextMesh.rotation.y = -angle;';
  html += 'scene.add(latchTextMesh);';
  html += 'gateCurrentPos += 10 * scale;';
  // Add gate label (890mm)
  html += 'const gateProgress = (gateCurrentPos + 445 * scale) / (sideLength * scale);';
  html += 'const gateLabelX = startPt[0] * scale + dx * scale * gateProgress;';
  html += 'const gateLabelZ = startPt[1] * scale + dy * scale * gateProgress;';
  html += 'const gateTextGeometry = new THREE.TextGeometry("890mm GATE", {';
  html += 'font: font, size: 0.05, height: 0.01';
  html += '});';
  html += 'const gateTextMaterial = new THREE.MeshBasicMaterial({ color: 0x00aa00 });';
  html += 'const gateTextMesh = new THREE.Mesh(gateTextGeometry, gateTextMaterial);';
  html += 'gateTextGeometry.computeBoundingBox();';
  html += 'const gateTextWidth = gateTextGeometry.boundingBox.max.x - gateTextGeometry.boundingBox.min.x;';
  html += 'const gateOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const gateOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'gateTextMesh.position.set(gateLabelX - gateTextWidth/2 + gateOffsetX, 1.0, gateLabelZ + gateOffsetZ);';
  html += 'gateTextMesh.rotation.y = -angle;';
  html += 'scene.add(gateTextMesh);';
  html += 'gateCurrentPos += 890 * scale;';
  // Add hinge label (5mm)
  html += 'const hingeProgress = (gateCurrentPos + 2.5 * scale) / (sideLength * scale);';
  html += 'const hingeLabelX = startPt[0] * scale + dx * scale * hingeProgress;';
  html += 'const hingeLabelZ = startPt[1] * scale + dy * scale * hingeProgress;';
  html += 'const hingeTextGeometry = new THREE.TextGeometry("5mm H", {';
  html += 'font: font, size: 0.03, height: 0.01';
  html += '});';
  html += 'const hingeTextMaterial = new THREE.MeshBasicMaterial({ color: 0xff6666 });';
  html += 'const hingeTextMesh = new THREE.Mesh(hingeTextGeometry, hingeTextMaterial);';
  html += 'hingeTextGeometry.computeBoundingBox();';
  html += 'const hingeTextWidth = hingeTextGeometry.boundingBox.max.x - hingeTextGeometry.boundingBox.min.x;';
  html += 'const hingeOffsetX = dy !== 0 ? 0.3 : 0;';
  html += 'const hingeOffsetZ = dx !== 0 ? 0.3 : 0;';
  html += 'hingeTextMesh.position.set(hingeLabelX - hingeTextWidth/2 + hingeOffsetX, 1.0, hingeLabelZ + hingeOffsetZ);';
  html += 'hingeTextMesh.rotation.y = -angle;';
  html += 'scene.add(hingeTextMesh);';
  html += 'gateCurrentPos += 5 * scale;';
  html += '}';
  html += 'currentPos = gateCurrentPos;';
  html += '} else if (panelIndex < layout.panelWidths.length - 1) {';
  html += 'currentPos += (layout.gap || 8) * scale;';
  html += '}';
  html += '});';
  html += '});';
  html += '});';
  
  // Add handrails if selected
  html += 'const handrailType = ' + JSON.stringify(data.handrailType || 'none') + ';';
  html += 'if (handrailType && handrailType !== "none") {';
  html += 'try {';
  html += 'const RAIL_PROFILES = {';
  html += '  "AH40": { dims: [0.040, 0.036], bevel: 0 },';
  html += '  "S25": { dims: [0.025, 0.021], bevel: 0.002 },';
  html += '  "S40": { dims: [0.040, 0.030], bevel: 0.002 },';
  html += '  "R40": { dia: 0.042 }';
  html += '};';
  html += 'const profile = RAIL_PROFILES[handrailType];';
  html += 'if (profile) {';
  html += 'const finishType = ' + JSON.stringify(data.finishType || 'mill') + ';';
  html += 'const isBlackFinish = finishType.toLowerCase().includes("black") || finishType.toLowerCase().includes("matt black");';
  html += 'let railMaterial;';
  html += 'if (isBlackFinish) {';
  html += 'railMaterial = new THREE.MeshStandardMaterial({';
  html += 'color: 0x2a2a2a,';
  html += 'metalness: 0.7,';
  html += 'roughness: 0.4,';
  html += 'envMapIntensity: 0.8';
  html += '});';
  html += '} else {';
  html += 'railMaterial = new THREE.MeshPhysicalMaterial({';
  html += 'color: 0xbfc5c9,';
  html += 'metalness: 0.85,';
  html += 'roughness: 0.25,';
  html += 'envMapIntensity: 1.2,';
  html += 'clearcoat: 0.1,';
  html += 'clearcoatRoughness: 0.3';
  html += '});';
  html += '}';
  html += 'let railGeometry;';
  html += 'if (profile.dims) {';
  html += 'const [w, h] = profile.dims;';
  html += 'railGeometry = new THREE.BoxGeometry(1, h, w);';
  html += '} else if (profile.dia) {';
  html += 'const r = profile.dia / 2;';
  html += 'railGeometry = new THREE.CylinderGeometry(r, r, 1, 24);';
  html += 'railGeometry.rotateZ(Math.PI / 2);';
  html += '}';
  html += 'runs.forEach((layout, sideIndex) => {';
  html += 'if (!pts[sideIndex] || !pts[sideIndex + 1]) return;';
  html += 'const startPt = pts[sideIndex];';
  html += 'const endPt = pts[sideIndex + 1];';
  html += 'const dx = endPt[0] - startPt[0];';
  html += 'const dy = endPt[1] - startPt[1];';
  html += 'const scale = 0.002;';
  html += 'const sideLength = Math.sqrt(dx * dx + dy * dy);';
  html += 'let currentPos = 0;';
  html += 'layout.panelWidths.forEach((panelWidth, panelIndex) => {';
  html += 'const panelLength = panelWidth * scale;';
  html += 'const rail = new THREE.Mesh(railGeometry, railMaterial);';
  html += 'const progress = (currentPos + panelLength / 2) / (sideLength * scale);';
  html += 'const x = startPt[0] * scale + dx * scale * progress;';
  html += 'const z = startPt[1] * scale + dy * scale * progress;';
  html += 'const panelHeight = 2.4;';
  html += 'rail.position.set(x, panelHeight + 0.02, z);';
  html += 'const angle = Math.atan2(dy, dx);';
  html += 'rail.rotation.y = -angle;';
  html += 'rail.scale.x = panelLength;';
  html += 'scene.add(rail);';
  html += 'currentPos += panelLength;';
  html += 'if (layout.gateSegment && panelIndex === layout.gateSegment.panelIndex) {';
  html += 'const __gateW = ((layout.gateSegment && (layout.gateSegment.totalWidth || layout.gateSegment.width)) ? (layout.gateSegment.totalWidth || layout.gateSegment.width) : 905) * scale; currentPos += __gateW;';
  html += '} else if (panelIndex < layout.panelWidths.length - 1) {';
  html += 'currentPos += (layout.gap || 8) * scale;';
  html += '}';
  html += '});';
  html += '});';
  html += '}';
  html += '} catch (e) {';
  html += 'console.warn("Handrail creation failed:", e);';
  html += '}';
  html += '}';
  html += '}';
  
  html += 'createFence3D();';
  html += 'addDimensionLabels();';
  html += 'function resetCamera() { camera.position.set(5, 4, 5); controls.target.set(0, 0, 0); controls.update(); }';
  html += 'function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }';
  html += 'window.addEventListener("resize", () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });';
  html += 'animate();';
  html += '<\/script>';
  html += '</body></html>';
  
  // When using continuous widths (glass-first mode), round panel labels to two decimals in the 3D view.
  try {
    html = html.replace(/const panelText = panelWidth \+ "mm";/g, 'const panelText = (Math.round(panelWidth * 100) / 100).toFixed(2) + "mm";');
  } catch (e) {
    console.warn('3D label rounding replacement failed:', e);
  }
  return html;
}

// --- Freehand SVG Pad Logic with Ghost Line, Larger Area, and 10x Scale ---
const svgPad = document.getElementById('svgGridPad');
const svgSection = document.getElementById('svgDrawSection');
const sideLengthsDiv = document.getElementById('svgSideLengths');
const submitBtn = document.getElementById('svgSubmitLayoutBtn');
const clearBtn = document.getElementById('svgClearBtn');
const doneBtn = document.getElementById('svgDoneBtn');
const editBtn = document.getElementById('svgEditBtn');

svgPad.setAttribute('width', '1200');
svgPad.setAttribute('height', '800');

// Zoom and pan variables for mouse wheel zoom
let zoomLevel = 1;
let panX = 600;  // Center X (half of 1200)
let panY = 400;  // Center Y (half of 800)
let isPanning = false;
let lastPanX = 0;
let lastPanY = 0;

const MM_PER_PIXEL = 10;

// Helper function to snap measurements to 5mm increments
function snapTo5mm(length) {
  const rawLength = Math.sqrt(length) * MM_PER_PIXEL;
  return Math.round(rawLength / 5) * 5;
}

// Helper function to snap angles to 5-degree increments
function snapTo5Degrees(angle) {
  return Math.round(angle / 5) * 5;
}

// Helper function to calculate angle between two lines in degrees
function calculateAngle(prevPoint, currentPoint, nextPoint) {
  // Vector from previous to current point
  const v1x = currentPoint.x - prevPoint.x;
  const v1y = currentPoint.y - prevPoint.y;
  
  // Vector from current to next point
  const v2x = nextPoint.x - currentPoint.x;
  const v2y = nextPoint.y - currentPoint.y;
  
  // Calculate angle using dot product and cross product
  const dot = v1x * v2x + v1y * v2y;
  const cross = v1x * v2y - v1y * v2x;
  
  let angle = Math.atan2(cross, dot) * (180 / Math.PI);
  
  // Convert to positive angle (0-360)
  if (angle < 0) angle += 360;
  
  // Return the supplementary angle (180 - angle) to start from 180°
  angle = 180 - angle;
  if (angle < 0) angle += 360;
  if (angle > 180) angle = 360 - angle;
  
  return snapTo5Degrees(angle);
}

// Function to detect corners and determine required joiners
function detectCornersAndJoiners() {
  let corners = [];
  
  // Check corners in finished shapes
  for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
    const shape = finishedShapes[shapeIndex];
    
    // Find corners within each shape (need at least 3 points)
    if (shape.length >= 3) {
      for (let i = 1; i < shape.length - 1; i++) {
        const prevPoint = shape[i - 1];
        const currentPoint = shape[i];
        const nextPoint = shape[i + 1];
        
        const angle = calculateAngle(prevPoint, currentPoint, nextPoint);
        
        // Only consider significant angle changes (not straight lines)
        if (Math.abs(angle - 180) > 10) { // 10 degree tolerance for "straight"
          corners.push({
            point: currentPoint,
            angle: angle,
            shapeIndex: shapeIndex,
            pointIndex: i,
            isNinetyDegree: angle === 90 // Only EXACTLY 90 degrees
          });
        }
      }
    }
  }
  
  // Check for connection points between different shapes (where shapes meet)
  const tolerance = 5; // 5 pixel tolerance for connection detection
  for(let shape1Index = 0; shape1Index < finishedShapes.length; shape1Index++) {
    const shape1 = finishedShapes[shape1Index];
    for(let shape2Index = shape1Index + 1; shape2Index < finishedShapes.length; shape2Index++) {
      const shape2 = finishedShapes[shape2Index];
      
      // Check if any endpoints of shape1 connect to any points of shape2
      [0, shape1.length - 1].forEach(shape1PointIndex => {
        const shape1Point = shape1[shape1PointIndex];
        
        shape2.forEach((shape2Point, shape2PointIndex) => {
          const distance = Math.sqrt(
            Math.pow(shape1Point.x - shape2Point.x, 2) + 
            Math.pow(shape1Point.y - shape2Point.y, 2)
          );
          
          if (distance <= tolerance) {
            // Found a connection! Calculate the actual angle at this point
            let angle = 180; // Default to straight line
            
            // Get the adjacent points to calculate the real angle
            let prevPoint = null;
            let nextPoint = null;
            
            // Get adjacent point from shape1
            if (shape1PointIndex === 0 && shape1.length > 1) {
              prevPoint = shape1[1]; // Next point in shape1
            } else if (shape1PointIndex === shape1.length - 1 && shape1.length > 1) {
              prevPoint = shape1[shape1.length - 2]; // Previous point in shape1
            }
            
            // Get adjacent point from shape2
            if (shape2PointIndex === 0 && shape2.length > 1) {
              nextPoint = shape2[1]; // Next point in shape2
            } else if (shape2PointIndex === shape2.length - 1 && shape2.length > 1) {
              nextPoint = shape2[shape2.length - 2]; // Previous point in shape2
            } else if (shape2PointIndex > 0 && shape2PointIndex < shape2.length - 1) {
              // Connection is in middle of shape2, use appropriate adjacent point
              nextPoint = shape2PointIndex === 0 ? shape2[1] : shape2[shape2PointIndex - 1];
            }
            
            // Calculate angle if we have both adjacent points
            if (prevPoint && nextPoint) {
              angle = calculateAngle(prevPoint, shape1Point, nextPoint);
            }
            
            // Add as corner only if it's not a straight line
            if (Math.abs(angle - 180) > 10) { // 10 degree tolerance for "straight"
              corners.push({
                point: shape1Point, // Use shape1 point as reference
                angle: angle,
                shapeIndex: shape1Index,
                pointIndex: shape1PointIndex,
                isNinetyDegree: Math.abs(angle - 90) < 5, // 5 degree tolerance for 90 degrees
                isConnection: true // Flag to indicate this is a connection point
              });
            }
          }
        });
      });
    }
  }
  
  // Check corners in current drawing
  if (points.length >= 3) {
    for (let i = 1; i < points.length - 1; i++) {
      const prevPoint = points[i - 1];
      const currentPoint = points[i];
      const nextPoint = points[i + 1];
      
      const angle = calculateAngle(prevPoint, currentPoint, nextPoint);
      
      // Only consider significant angle changes (not straight lines)  
      if (Math.abs(angle - 180) > 10) { // 10 degree tolerance for "straight"
        corners.push({
          point: currentPoint,
          angle: angle,
          shapeIndex: -1, // -1 indicates current drawing
          pointIndex: i,
          isNinetyDegree: angle === 90 // Only EXACTLY 90 degrees
        });
      }
    }
  }
  
  return corners;
}

// Function to get joiner code based on handrail type and angle
function getJoinerCode(handrailType, isNinetyDegree) {
  if (isNinetyDegree) {
    // 90 degree corner joiners
    switch(handrailType) {
      case 'S25': return 'S25J90';
      case 'S40': return 'S40J90';
      case 'AH40': return 'AHJ90';
      case 'R40': return 'R40J90';
      default: return 'J90'; // Generic if handrail type not recognized
    }
  } else {
    // Adjustable horizontal joiners
    switch(handrailType) {
      case 'S25': return 'S25HAJ';
      case 'S40': return 'S40HAJ';
      case 'AH40': return 'AHAHJ';
      case 'R40': return 'R40HAJ';
      default: return 'HAJ'; // Generic if handrail type not recognized
    }
  }
}

// Zoom utility functions
function updateViewBox() {
  const width = 1200 / zoomLevel;
  const height = 800 / zoomLevel;
  const x = panX - width / 2;
  const y = panY - height / 2;
  svgPad.setAttribute('viewBox', `${x} ${y} ${width} ${height}`);
}

function handleMouseWheel(e) {
  // Only zoom when Ctrl key is held down
  if (!e.ctrlKey) {
    return; // Allow normal scrolling behavior
  }
  
  e.preventDefault();
  
  // Get mouse position relative to SVG
  const rect = svgPad.getBoundingClientRect();
  const mouseX = (e.clientX - rect.left) / rect.width * 1200;
  const mouseY = (e.clientY - rect.top) / rect.height * 800;
  
  // Determine zoom direction and factor
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  const newZoom = Math.max(0.5, Math.min(5, zoomLevel * zoomFactor));
  
  if (newZoom !== zoomLevel) {
    // Zoom towards mouse position
    panX += (mouseX - panX) * (1 - newZoom / zoomLevel);
    panY += (mouseY - panY) * (1 - newZoom / zoomLevel);
    zoomLevel = newZoom;
    updateViewBox();
  }
}

// Pan functions for Ctrl+drag
function handleMouseDown(e) {
  if (e.ctrlKey && e.button === 0) { // Ctrl + Left mouse button for pan
    e.preventDefault();
    isPanning = true;
    lastPanX = e.clientX;
    lastPanY = e.clientY;
    svgPad.style.cursor = 'move';
    wasMouseMoved = false; // Reset movement tracking
  }
}

function handleMouseMove(e) {
  if (isPanning) {
    e.preventDefault();
    e.stopPropagation(); // Prevent drawing while panning
    
    const deltaX = (e.clientX - lastPanX) / zoomLevel;
    const deltaY = (e.clientY - lastPanY) / zoomLevel;
    panX -= deltaX;
    panY -= deltaY;
    lastPanX = e.clientX;
    lastPanY = e.clientY;
    updateViewBox();
    wasMouseMoved = true; // Mark that mouse was moved during pan
    return; // Don't process as drawing move
  }
}

function handleMouseUp(e) {
  if (isPanning) {
    isPanning = false;
    svgPad.style.cursor = 'crosshair';
    e.preventDefault();
    e.stopPropagation(); // Prevent click from registering as drawing
    
    // Set a timeout to clear the movement flag to prevent clicks immediately after panning
    setTimeout(() => {
      wasMouseMoved = false;
    }, 100);
  }
}

let points = [];
let finishedShapes = []; // Array of completed shapes (each shape is an array of points)
let ghost = null;
let isDrawingMode = true; // Track drawing state
let currentDrawingPoint = null; // Track which point we're drawing from
let currentDrawingPointIndex = null; // Track the index of the point we're drawing from
const SNAP_R = 15; // px radius to “grab” an old point

// Helper function to check if a point is already connected in the sequence
function isPointInSequence(point, pointsArray) {
  return pointsArray.some(p => p.x === point.x && p.y === point.y);
}

function nearestPoint(mx, my) {
  let hit = -1, best = SNAP_R * SNAP_R;
  points.forEach((p, i) => {
    const dx = mx - p.x, dy = my - p.y, d2 = dx*dx + dy*dy;
    if (d2 < best) { best = d2; hit = i; }
  });
  return hit;
}

function clientToSvg(e){
  // Create an SVG point
  const pt = svgPad.createSVGPoint();
  pt.x = e.clientX;
  pt.y = e.clientY;
  
  // Transform the point from screen coordinates to SVG coordinates
  // This automatically accounts for all transformations including viewBox
  const svgPt = pt.matrixTransform(svgPad.getScreenCTM().inverse());
  
  return { x: svgPt.x, y: svgPt.y };
}

function drawFreehandPad() {
  svgPad.innerHTML = '';
  
  // Add grid pattern
  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
  pattern.setAttribute('id', 'grid');
  pattern.setAttribute('width', '50');
  pattern.setAttribute('height', '50');
  pattern.setAttribute('patternUnits', 'userSpaceOnUse');
  
  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', 'M 50 0 L 0 0 0 50');
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke', '#e0e0e0');
  path.setAttribute('stroke-width', '1');
  
  pattern.appendChild(path);
  defs.appendChild(pattern);
  svgPad.appendChild(defs);
  
  // Add grid background - make it extend far beyond the viewable area
  const gridRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  gridRect.setAttribute('x', '-10000');
  gridRect.setAttribute('y', '-10000');
  gridRect.setAttribute('width', '20000');
  gridRect.setAttribute('height', '20000');
  gridRect.setAttribute('fill', 'url(#grid)');
  svgPad.appendChild(gridRect);
  
  let globalSideCounter = 0; // Counter for side labeling across all shapes
  
  // Draw all finished shapes with labels
  for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
    const shape = finishedShapes[shapeIndex];
    for(let k=1; k<shape.length; k++) {
      const a = shape[k-1], b = shape[k];
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',a.x);line.setAttribute('y1',a.y);
      line.setAttribute('x2',b.x);line.setAttribute('y2',b.y);
      line.setAttribute('stroke','#888'); // Slightly lighter for finished shapes
      line.setAttribute('stroke-width',2);
      svgPad.appendChild(line);
      
      // Add side label for finished shapes
      const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
      const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
      const sideLetter = String.fromCharCode(65 + globalSideCounter); // A, B, C, etc.
      
      const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
      lbl.textContent = `${sideLetter}: ${len} mm`;
      lbl.setAttribute('x', mx);
      lbl.setAttribute('y', my - 8);
      lbl.setAttribute('font-size', '14');
      lbl.setAttribute('fill', '#666'); // Slightly lighter for finished shapes
      lbl.setAttribute('font-weight', '600');
      lbl.setAttribute('text-anchor', 'middle');
      lbl.setAttribute('pointer-events', 'none'); // Prevent blocking clicks
      svgPad.appendChild(lbl);
      
      globalSideCounter++;
    }
  }
  
  // Draw current active drawing lines with labels
  for(let k=1;k<points.length;k++) {
    const a = points[k-1], b = points[k];
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',a.x);line.setAttribute('y1',a.y);
    line.setAttribute('x2',b.x);line.setAttribute('y2',b.y);
    line.setAttribute('stroke','#222');
    line.setAttribute('stroke-width',3);
    svgPad.appendChild(line);
    
    // Add side label for active drawing
    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
    const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
    const sideLetter = String.fromCharCode(65 + globalSideCounter); // Continue lettering
    
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.textContent = `${sideLetter}: ${len} mm`;
    lbl.setAttribute('x', mx);
    lbl.setAttribute('y', my - 8);
    lbl.setAttribute('font-size', '14');
    lbl.setAttribute('fill', '#0077c8'); // Blue for active drawing
    lbl.setAttribute('font-weight', '600');
    lbl.setAttribute('text-anchor', 'middle');
    lbl.setAttribute('pointer-events', 'none'); // Prevent blocking clicks
    svgPad.appendChild(lbl);
    
    globalSideCounter++;
  }
  
  // Draw clickable point circles when not in drawing mode
  if (!isDrawingMode) {
    // Show blue dots for current points
    for(let i=0; i<points.length; i++) {
      const point = points[i];
      const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circle.setAttribute('cx', point.x);
      circle.setAttribute('cy', point.y);
      circle.setAttribute('r', '15');
      circle.setAttribute('fill', '#0077c8');
      circle.setAttribute('stroke', '#fff');
      circle.setAttribute('stroke-width', '3');
      circle.setAttribute('cursor', 'pointer');
      circle.setAttribute('data-point-index', i);
      circle.addEventListener('click', (e) => {
        e.stopPropagation();
        resumeDrawingFromPoint(i);
      });
      svgPad.appendChild(circle);
    }
    
    // Show blue dots for finished shapes
    for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
      const shape = finishedShapes[shapeIndex];
      for(let pointIndex = 0; pointIndex < shape.length; pointIndex++) {
        const point = shape[pointIndex];
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', '12');
        circle.setAttribute('fill', '#0077c8');
        circle.setAttribute('stroke', '#fff');
        circle.setAttribute('stroke-width', '2');
        circle.setAttribute('cursor', 'pointer');
        circle.addEventListener('click', (e) => {
          e.stopPropagation();
          resumeDrawingFromFinishedPoint(shapeIndex, pointIndex);
        });
        svgPad.appendChild(circle);
      }
    }
  } else {
    // In drawing mode, show blue dots only if currentDrawingPoint is not set (user needs to select starting point)
    if (!currentDrawingPoint && points.length > 0) {
      for(let i=0; i<points.length; i++) {
        const point = points[i];
        const circle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        circle.setAttribute('cx', point.x);
        circle.setAttribute('cy', point.y);
        circle.setAttribute('r', '15');
        circle.setAttribute('fill', '#0077c8');
        circle.setAttribute('stroke', '#fff');
        circle.setAttribute('stroke-width', '3');
        circle.setAttribute('cursor', 'pointer');
        circle.setAttribute('data-point-index', i);
        circle.addEventListener('click', (e) => {
          e.stopPropagation();
          resumeDrawingFromPoint(i);
        });
        svgPad.appendChild(circle);
      }
    }
  }
  // Draw ghost line if present
  if(currentDrawingPoint && ghost) {
    const a = currentDrawingPoint, b = ghost;
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',a.x);line.setAttribute('y1',a.y);
    line.setAttribute('x2',b.x);line.setAttribute('y2',b.y);
    line.setAttribute('stroke','#0077c8');
    line.setAttribute('stroke-width',2);
    line.setAttribute('stroke-dasharray','8,6');
    svgPad.appendChild(line);
    // Live measurement label for ghost line
    const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
    const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.textContent = `${len} mm`;
    lbl.setAttribute('x', mx);
    lbl.setAttribute('y', my - 18);
    lbl.setAttribute('font-size', '16');
    lbl.setAttribute('fill', '#0077c8');
    lbl.setAttribute('text-anchor', 'middle');
    lbl.setAttribute('font-weight', 'bold');
    svgPad.appendChild(lbl);
    
    // Show angle indicator if we have a previous point
    if(points.length >= 2) {
      const prevPoint = points[points.length - 2];
      const angle = calculateAngle(prevPoint, a, b);
      
      // Create angle arc indicator
      const radius = 40;
      const startAngle = Math.atan2(prevPoint.y - a.y, prevPoint.x - a.x);
      const endAngle = Math.atan2(b.y - a.y, b.x - a.x);
      
      const startX = a.x + radius * Math.cos(startAngle);
      const startY = a.y + radius * Math.sin(startAngle);
      const endX = a.x + radius * Math.cos(endAngle);
      const endY = a.y + radius * Math.sin(endAngle);
      
      // Calculate arc direction (shortest path)
      let angleDiff = endAngle - startAngle;
      if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
      if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
      const sweepFlag = angleDiff > 0 ? 1 : 0;
      const largeArcFlag = Math.abs(angleDiff) > Math.PI ? 1 : 0;
      
      const arc = document.createElementNS('http://www.w3.org/2000/svg','path');
      const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
      arc.setAttribute('d', pathData);
      arc.setAttribute('stroke', '#0077c8');
      arc.setAttribute('stroke-width', 2);
      arc.setAttribute('fill', 'none');
      arc.setAttribute('stroke-dasharray', '4,3');
      svgPad.appendChild(arc);
      
      // Create angle label
      const labelRadius = radius + 20;
      const labelAngle = (startAngle + endAngle) / 2;
      const labelX = a.x + labelRadius * Math.cos(labelAngle);
      const labelY = a.y + labelRadius * Math.sin(labelAngle);
      
      const angleLabel = document.createElementNS('http://www.w3.org/2000/svg','text');
      angleLabel.setAttribute('x', labelX);
      angleLabel.setAttribute('y', labelY + 5);
      angleLabel.setAttribute('text-anchor', 'middle');
      angleLabel.setAttribute('font-size', '14');
      angleLabel.setAttribute('fill', '#0077c8');
      angleLabel.setAttribute('font-weight', 'bold');
      angleLabel.textContent = angle + '°';
      svgPad.appendChild(angleLabel);
    }
    
    // Draw + cursor at ghost point
    const cross1 = document.createElementNS('http://www.w3.org/2000/svg','line');
    cross1.setAttribute('x1', b.x - 10); cross1.setAttribute('y1', b.y);
    cross1.setAttribute('x2', b.x + 10); cross1.setAttribute('y2', b.y);
    cross1.setAttribute('stroke', '#0077c8');
    cross1.setAttribute('stroke-width', 2);
    svgPad.appendChild(cross1);
    const cross2 = document.createElementNS('http://www.w3.org/2000/svg','line');
    cross2.setAttribute('x1', b.x); cross2.setAttribute('y1', b.y - 10);
    cross2.setAttribute('x2', b.x); cross2.setAttribute('y2', b.y + 10);
    cross2.setAttribute('stroke', '#0077c8');
    cross2.setAttribute('stroke-width', 2);
    svgPad.appendChild(cross2);
  }
  // Draw points
  points.forEach((p,i) => {
    const dot = document.createElementNS('http://www.w3.org/2000/svg','circle');
    dot.setAttribute('cx',p.x);dot.setAttribute('cy',p.y);
    dot.setAttribute('r',7);
    dot.setAttribute('fill','#0077c8');
    svgPad.appendChild(dot);
    // Label point
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.textContent = String.fromCharCode(65+i);
    lbl.setAttribute('x',p.x+12);lbl.setAttribute('y',p.y-12);
    lbl.setAttribute('font-size','16');lbl.setAttribute('fill','#0077c8');
    lbl.setAttribute('font-weight','bold');
    svgPad.appendChild(lbl);
  });
  // Draw side labels
  for(let k=1;k<points.length;k++) {
    const a = points[k-1], b = points[k];
    const mx = (a.x+b.x)/2, my = (a.y+b.y)/2;
    const len = Math.round(Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2) * MM_PER_PIXEL);
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.textContent = String.fromCharCode(65+k-1)+': '+len+' mm';
    lbl.setAttribute('x',mx);lbl.setAttribute('y',my-10);
    lbl.setAttribute('font-size','14');lbl.setAttribute('fill','#0077c8');
    lbl.setAttribute('text-anchor','middle');
    lbl.setAttribute('font-weight','600');
    svgPad.appendChild(lbl);
  }
  
  // Draw corner markers
  const corners = detectCornersAndJoiners();
  corners.forEach((corner, index) => {
    // Draw corner marker circle
    const marker = document.createElementNS('http://www.w3.org/2000/svg','circle');
    marker.setAttribute('cx', corner.point.x);
    marker.setAttribute('cy', corner.point.y);
    marker.setAttribute('r', '18');
    marker.setAttribute('fill', corner.isNinetyDegree ? '#28a745' : '#ffc107'); // Green for 90°, yellow for adjustable
    marker.setAttribute('stroke', '#fff');
    marker.setAttribute('stroke-width', '3');
    marker.setAttribute('opacity', '0.8');
    svgPad.appendChild(marker);
    
    // Add corner angle text
    const cornerText = document.createElementNS('http://www.w3.org/2000/svg','text');
    cornerText.textContent = corner.isNinetyDegree ? '90°' : `${corner.angle}°`;
    cornerText.setAttribute('x', corner.point.x);
    cornerText.setAttribute('y', corner.point.y + 5);
    cornerText.setAttribute('font-size', '12');
    cornerText.setAttribute('font-weight', 'bold');
    cornerText.setAttribute('fill', '#fff');
    cornerText.setAttribute('text-anchor', 'middle');
    cornerText.setAttribute('pointer-events', 'none');
    svgPad.appendChild(cornerText);
  });
}

svgPad.onclick = function(e) {
  // Prevent drawing if we just finished panning or if Ctrl is held down
  if (isPanning || e.ctrlKey) return;
  
  if (!isDrawingMode) return; // Only allow clicks in drawing mode
  if (!currentDrawingPoint && points.length > 0) return; // Must select a blue dot first if points exist
  
  let newPoint;
  
  // If we have a ghost point (which is already angle-snapped), use that exact position
  if (ghost) {
    newPoint = { x: ghost.x, y: ghost.y }; // Use the exact snapped ghost position
  } else {
    // Fallback to direct mouse position if no ghost
    newPoint = clientToSvg(e);
  }
  
  // Normal drawing - just add to end of current drawing
  points.push(newPoint);
  currentDrawingPoint = newPoint; // Update current drawing point to the new point
  ghost = null;
  drawFreehandPad();
  updateFreehandSideLengths();
};

svgPad.onmousemove = function(e) {
  // If we're panning, the handleMouseMove will handle it
  if (isPanning) {
    return;
  }
  
  // Don't show ghost lines when Ctrl is held down (navigation mode)
  if (e.ctrlKey) {
    return;
  }
  
  if(currentDrawingPoint && isDrawingMode) { // Only show ghost line when a drawing point is selected
    let mousePoint = clientToSvg(e);
    
    // Apply angle snapping if we have a previous point to reference
    if (points.length > 0) {
      const referencePoint = points[points.length - 1]; // Last drawn point
      ghost = snapPointToAngle(referencePoint, mousePoint, 5); // Snap to 5-degree increments
    } else {
      ghost = mousePoint; // No snapping for first point
    }
    
    drawFreehandPad();
  }
};

// Function to snap a point to angle-snapped position relative to a reference point
function snapPointToAngle(referencePoint, currentPoint, increment = 5) {
  const dx = currentPoint.x - referencePoint.x;
  const dy = currentPoint.y - referencePoint.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  
  if (distance < 1) return currentPoint; // Too close to snap meaningfully
  
  // Calculate the current angle in degrees
  const currentAngleDegrees = Math.atan2(dy, dx) * (180 / Math.PI);
  
  // FORCE snap to nearest 5-degree increment
  const snappedAngleDegrees = Math.round(currentAngleDegrees / increment) * increment;
  
  // Convert back to radians
  const snappedAngleRadians = snappedAngleDegrees * (Math.PI / 180);
  
  // Return point at EXACT snapped angle
  return {
    x: referencePoint.x + distance * Math.cos(snappedAngleRadians),
    y: referencePoint.y + distance * Math.sin(snappedAngleRadians)
  };
}

svgPad.onmouseleave = function() {
  ghost = null;
  drawFreehandPad();
};

function updateFreehandSideLengths() {
  let html = '';
  let sideCounter = 0;
  
  // Add measurements for finished shapes
  for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
    const shape = finishedShapes[shapeIndex];
    for(let k=1; k<shape.length; k++) {
      const a = shape[k-1], b = shape[k];
      const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
      html += `
        <div style="display:inline-block; margin:2px 8px; padding:6px; background:rgba(0,119,200,0.1); border-radius:3px; text-align:center;">
          <div style="font-weight:bold; margin-bottom:4px;">Side ${String.fromCharCode(65+sideCounter)}: ${len} mm</div>
          <label style="display:flex;align-items:center;gap:0.4rem;font-size:0.85rem;color:#444;cursor:pointer;justify-content:center;margin-top:2px;">
            <input type="checkbox" class="customGateRequired" data-side="${sideCounter}" style="margin:0;transform:scale(1.1);">
            <span style="font-weight:500;">Gate</span>
          </label>
        </div>`;
      sideCounter++;
    }
  }
  
  // Add measurements for current active drawing
  for(let k=1; k<points.length; k++) {
    const a = points[k-1], b = points[k];
    const len = snapTo5mm((a.x-b.x)**2+(a.y-b.y)**2);
    html += `
      <div style="display:inline-block; margin:2px 8px; padding:6px; background:rgba(0,119,200,0.1); border-radius:3px; text-align:center;">
        <div style="font-weight:bold; margin-bottom:4px;">Side ${String.fromCharCode(65+sideCounter)}: ${len} mm</div>
        <label style="display:flex;align-items:center;gap:0.4rem;font-size:0.85rem;color:#444;cursor:pointer;justify-content:center;margin-top:2px;">
          <input type="checkbox" class="customGateRequired" data-side="${sideCounter}" style="margin:0;transform:scale(1.1);">
          <span style="font-weight:500;">Gate</span>
        </label>
      </div>`;
    sideCounter++;
  }
  
  sideLengthsDiv.innerHTML = html || 'Click points on the drawing area to start creating your fence layout...';
  
  // Add event handlers for custom gate checkboxes
  if (sideCounter > 0) {
    document.querySelectorAll('.customGateRequired').forEach(checkbox => {
      checkbox.onchange = () => {
        drawFreehandPad(); // Refresh the drawing
        // Don't call updateFreehandSideLengths() here to avoid infinite loop
      };
    });
  }
}

function showSvgPad() {
  points = [];
  ghost = null;
  currentDrawingPoint = null;
  isDrawingMode = true;
  updateUI();
  drawFreehandPad();
  updateFreehandSideLengths();
  svgSection.style.display = '';
}

function clearSvgPad() {
  // Show confirmation dialog before clearing
  const confirmClear = confirm('Are you sure you want to clear the entire drawing? This action cannot be undone.');
  
  if (!confirmClear) {
    return; // User cancelled, don't clear
  }
  
  // Save state before clearing
  saveDrawingState();
  
  points = [];
  finishedShapes = []; // Also clear finished shapes
  ghost = null;
  currentDrawingPoint = null; // Reset current drawing point
  isDrawingMode = true; // Reset to drawing mode
  updateUI();
  drawFreehandPad();
  updateFreehandSideLengths();
}

// --- Integrate SVG pad output with calculator ---
submitBtn.onclick = function() {
  // Calculate total sides from finished shapes and current drawing
  let totalSides = 0;
  let allSides = []; // Array to store all side data with direction vectors
  
  // Add sides from finished shapes
  for(let shapeIndex = 0; shapeIndex < finishedShapes.length; shapeIndex++) {
    const shape = finishedShapes[shapeIndex];
    for(let k = 1; k < shape.length; k++) {
      const a = shape[k-1], b = shape[k];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const length = snapTo5mm((dx*dx)+(dy*dy));
      allSides.push({
        id: String.fromCharCode(65 + totalSides),
        length: length,
        dx: dx * MM_PER_PIXEL, // Convert to mm
        dy: dy * MM_PER_PIXEL  // Convert to mm
      });
      totalSides++;
    }
  }
  
  // Add sides from current drawing
  for(let k = 1; k < points.length; k++) {
    const a = points[k-1], b = points[k];
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const length = snapTo5mm((dx*dx)+(dy*dy));
    allSides.push({
      id: String.fromCharCode(65 + totalSides),
      length: length,
      dx: dx * MM_PER_PIXEL, // Convert to mm
      dy: dy * MM_PER_PIXEL  // Convert to mm
    });
    totalSides++;
  }
  
  if(totalSides < 1) {
    alert('Please draw at least one side to create input fields.');
    return;
  }
  
  // Store the custom shape data globally for use by PDF and 3D systems
  window.customShapeData = {
    runs: allSides,
    isCustom: true
  };
  
  // Clear existing side inputs
  const sideInputsDiv = document.getElementById('sideInputs');
  sideInputsDiv.innerHTML = '';
  
  // Create dynamic side input boxes based on all drawn sides
  let sideInputsHTML = '<div class="grid">';
  
  for(let k = 0; k < totalSides; k++) {
    const sideData = allSides[k];
    const sideLetter = sideData.id;
    
    sideInputsHTML += `
      <div class="input-group">
        <label for="side${sideLetter}">Side ${sideLetter}:</label>
        <input type="number" id="side${sideLetter}" class="spanLen" value="${sideData.length}" min="100" max="6000" step="1">
        <span class="unit">mm</span>
      </div>
    `;
  }
  
  // Update spans array for calculation (keep backward compatibility)
  spans = allSides.map(s => s.length); // Use lengths for existing calculations
  
  sideInputsHTML += '</div>';
  sideInputsDiv.innerHTML = sideInputsHTML;
  
  // Ensure dropdowns are populated
  refreshSelectors();
  
  // Show success message
  const msg = document.createElement('div');
  msg.textContent = `✓ Created ${totalSides} side inputs from your drawing!`;
  msg.style.cssText = 'background:#d4edda;color:#155724;padding:10px;border-radius:5px;margin:10px 0;text-align:center;font-weight:bold;border:1px solid #c3e6cb;';
  sideInputsDiv.insertBefore(msg, sideInputsDiv.firstChild);
  setTimeout(() => msg.remove(), 4000);
};

// Function to handle resuming drawing from a specific point
function resumeDrawingFromPoint(pointIndex) {
  isDrawingMode = true;
  
  // Save the current shape as finished if it has at least 2 points
  if (points.length >= 2) {
    finishedShapes.push([...points]); // Save a copy of current points as finished shape
  }
  
  // Start a new drawing from the selected point
  const selectedPoint = points[pointIndex];
  points = [selectedPoint]; // Start new drawing with just the selected point
  
  currentDrawingPoint = selectedPoint;
  currentDrawingPointIndex = null; // Reset index since we're starting fresh
  updateUI();
  drawFreehandPad();
}

// Function to handle resuming drawing from a point in a finished shape
function resumeDrawingFromFinishedPoint(shapeIndex, pointIndex) {
  isDrawingMode = true;
  
  // Get the selected point from the finished shape
  const selectedPoint = finishedShapes[shapeIndex][pointIndex];
  
  // Save current points as finished if they exist
  if (points.length >= 2) {
    finishedShapes.push([...points]);
  }
  
  // Start new drawing from the selected finished point
  points = [selectedPoint];
  currentDrawingPoint = selectedPoint;
  currentDrawingPointIndex = null;
  updateUI();
  drawFreehandPad();
}

// Function to update UI based on drawing state
function updateUI() {
  if (isDrawingMode) {
    doneBtn.style.display = 'inline-block';
    editBtn.style.display = 'none';
    svgPad.style.cursor = 'crosshair';
  } else {
    doneBtn.style.display = 'none';
    editBtn.style.display = 'inline-block';
    svgPad.style.cursor = 'default';
  }
}

// Done button - stops drawing mode
doneBtn.onclick = () => {
  // Save state before making changes
  saveDrawingState();
  
  // Save current drawing as finished shape if it has at least 2 points (forms a line)
  if (points.length >= 2) {
    finishedShapes.push([...points]); // Save a copy of current points as finished shape
    points = []; // Clear current drawing
  }
  
  isDrawingMode = false;
  ghost = null; // Clear any ghost line
  currentDrawingPoint = null; // Clear drawing point
  updateUI();
  drawFreehandPad();
  updateFreehandSideLengths(); // Update measurements to include the newly finished shape
};

// Edit button - enables drawing mode
editBtn.onclick = () => {
  isDrawingMode = true;
  currentDrawingPoint = null; // Clear current drawing point so user must select one
  currentDrawingPointIndex = null; // Clear the drawing point index
  updateUI();
  drawFreehandPad();
};

clearBtn.onclick = clearSvgPad;

// Undo/Redo functionality
let drawingHistory = []; // Array to store drawing states
let historyIndex = -1; // Current position in history
const MAX_HISTORY = 50; // Maximum number of undo states to keep

// Save current drawing state to history
function saveDrawingState() {
  // Remove any future history if we're not at the end
  if (historyIndex < drawingHistory.length - 1) {
    drawingHistory = drawingHistory.slice(0, historyIndex + 1);
  }
  
  // Create a deep copy of the current state
  const state = {
    points: JSON.parse(JSON.stringify(points)),
    finishedShapes: JSON.parse(JSON.stringify(finishedShapes)),
    currentDrawingPoint: currentDrawingPoint ? {...currentDrawingPoint} : null,
    isDrawingMode: isDrawingMode
  };
  
  drawingHistory.push(state);
  historyIndex++;
  
  // Keep history within limits
  if (drawingHistory.length > MAX_HISTORY) {
    drawingHistory.shift();
    historyIndex--;
  }
  
  updateUndoRedoButtons();
}

// Restore drawing state from history
function restoreDrawingState(state) {
  points = JSON.parse(JSON.stringify(state.points));
  finishedShapes = JSON.parse(JSON.stringify(state.finishedShapes));
  currentDrawingPoint = state.currentDrawingPoint ? {...state.currentDrawingPoint} : null;
  isDrawingMode = state.isDrawingMode;
  ghost = null;
  
  drawFreehandPad();
  updateFreehandSideLengths();
  updateUI();
}

// Undo last action
function undoDrawing() {
  if (historyIndex > 0) {
    historyIndex--;
    restoreDrawingState(drawingHistory[historyIndex]);
    updateUndoRedoButtons();
  }
}

// Redo last undone action
function redoDrawing() {
  if (historyIndex < drawingHistory.length - 1) {
    historyIndex++;
    restoreDrawingState(drawingHistory[historyIndex]);
    updateUndoRedoButtons();
  }
}

// Update undo/redo button states
function updateUndoRedoButtons() {
  const undoBtn = document.getElementById('svgUndoBtn');
  const redoBtn = document.getElementById('svgRedoBtn');
  
  if (undoBtn) {
    undoBtn.disabled = historyIndex <= 0;
    undoBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
  }
  
  if (redoBtn) {
    redoBtn.disabled = historyIndex >= drawingHistory.length - 1;
    redoBtn.style.opacity = historyIndex >= drawingHistory.length - 1 ? '0.5' : '1';
  }
}

// Add mouse wheel zoom functionality to SVG pad
svgPad.addEventListener('wheel', handleMouseWheel, { passive: false });

// Add pan functionality to SVG pad
svgPad.addEventListener('mousedown', handleMouseDown);
svgPad.addEventListener('mousemove', handleMouseMove);
svgPad.addEventListener('mouseup', handleMouseUp);

// Disable the onclick handler and replace with mousedown/mouseup for better control
// svgPad.onclick = ... (disabled)

// Better click handling with mousedown/mouseup
let mouseDownPoint = null;
let mouseDownTime = 0;

svgPad.addEventListener('mousedown', function(e) {
  if (e.ctrlKey || !isDrawingMode) return;
  if (e.button !== 0) return; // Only left mouse button
  
  mouseDownPoint = clientToSvg(e);
  mouseDownTime = Date.now();
});

svgPad.addEventListener('mouseup', function(e) {
  if (e.ctrlKey || !isDrawingMode) return;
  if (e.button !== 0) return; // Only left mouse button
  if (!mouseDownPoint) return;
  if (!currentDrawingPoint && points.length > 0) return;
  
  // Prevent multiple simultaneous clicks
  if (isProcessingClick) {
    mouseDownPoint = null;
    return;
  }
  
  // Prevent drawing if we were panning
  if (wasMouseMoved) {
    wasMouseMoved = false;
    mouseDownPoint = null;
    return;
  }
  
  const mouseUpPoint = clientToSvg(e);
  const clickDuration = Date.now() - mouseDownTime;
  
  // Ensure it was a quick click, not a drag
  const dragDistance = Math.sqrt(
    Math.pow(mouseUpPoint.x - mouseDownPoint.x, 2) + 
    Math.pow(mouseUpPoint.y - mouseDownPoint.y, 2)
  );
  
  if (dragDistance > 5 || clickDuration > 500) {
    mouseDownPoint = null;
    return; // Was a drag or too long a press
  }
  
  isProcessingClick = true;
  
  try {
    const now = Date.now();
    const newPoint = mouseUpPoint;
    
    // Prevent rapid successive clicks
    if (now - lastClickTime < DOUBLE_CLICK_THRESHOLD) {
      return;
    }
    
    // Prevent 0-length or very short lines
    if (currentDrawingPoint) {
      const distance = Math.sqrt(
        Math.pow(newPoint.x - currentDrawingPoint.x, 2) + 
        Math.pow(newPoint.y - currentDrawingPoint.y, 2)
      );
      
      if (distance < MIN_CLICK_DISTANCE) {
        return; // Too close to last point, ignore this click
      }
    }
    
    // Save state before drawing
    saveDrawingState();
    
    // Normal drawing - just add to end of current drawing
    points.push(newPoint);
    currentDrawingPoint = newPoint;
    ghost = null;
    drawFreehandPad();
    updateFreehandSideLengths();
    
    // Update click tracking
    lastClickTime = now;
    lastClickPoint = newPoint;
    
  } finally {
    mouseDownPoint = null;
    setTimeout(() => {
      isProcessingClick = false;
    }, 50);
  }
});

// Add SVG drawing event handlers

// Variables for improved click handling
let lastClickTime = 0;
let lastClickPoint = null;
let wasMouseMoved = false;
let isProcessingClick = false; // Prevent multiple simultaneous clicks
const MIN_CLICK_DISTANCE = 10; // Increased minimum distance in pixels
const DOUBLE_CLICK_THRESHOLD = 400; // Increased time threshold

// Convert screen coordinates to SVG coordinates accounting for zoom/pan
function clientToSvg(e) {
  const pt = svgPad.createSVGPoint();
  pt.x = e.clientX;
  pt.y = e.clientY;
  
  // Transform through the inverse of the SVG's screen transformation matrix
  const svgPoint = pt.matrixTransform(svgPad.getScreenCTM().inverse());
  
  return { x: svgPoint.x, y: svgPoint.y };
}

/*
// Old onclick handler - replaced with better mousedown/mouseup approach below
svgPad.onclick = function(e) {
  // Don't draw if Ctrl is held (navigation mode) or not in drawing mode
  if (e.ctrlKey || !isDrawingMode) return;
  if (!currentDrawingPoint && points.length > 0) return; // Must select a blue dot first if points exist
  
  // Prevent multiple simultaneous clicks
  if (isProcessingClick) {
    return;
  }
  
  // Prevent drawing if we were panning
  if (wasMouseMoved) {
    wasMouseMoved = false;
    return;
  }
  
  isProcessingClick = true;
  
  try {
    const now = Date.now();
    const newPoint = clientToSvg(e);
    
    // Prevent rapid successive clicks (double-clicking)
    if (now - lastClickTime < DOUBLE_CLICK_THRESHOLD) {
      return;
    }
    
    // Prevent 0-length or very short lines
    if (currentDrawingPoint) {
      const distance = Math.sqrt(
        Math.pow(newPoint.x - currentDrawingPoint.x, 2) + 
        Math.pow(newPoint.y - currentDrawingPoint.y, 2)
      );
      
      if (distance < MIN_CLICK_DISTANCE) {
        return; // Too close to last point, ignore this click
      }
    }
    
    // Save state before drawing
    saveDrawingState();
    
    // Normal drawing - just add to end of current drawing
    points.push(newPoint);
    currentDrawingPoint = newPoint; // Update current drawing point to the new point
    ghost = null;
    drawFreehandPad();
    updateFreehandSideLengths();
    
    // Update click tracking
    lastClickTime = now;
    lastClickPoint = newPoint;
    
  } finally {
    // Always release the processing lock, even if there was an error
    setTimeout(() => {
      isProcessingClick = false;
    }, 50);
  }
};
*/

svgPad.onmousemove = function(e) {
  // Don't show ghost line if Ctrl is held (navigation mode)
  if (e.ctrlKey) return;
  
  if(currentDrawingPoint && isDrawingMode) { // Only show ghost line when a drawing point is selected
    ghost = clientToSvg(e);
    drawFreehandPad();
  }
};

svgPad.onmouseleave = function() {
  ghost = null;
  drawFreehandPad();
};

// Add event listeners for undo/redo buttons
document.getElementById('svgUndoBtn').onclick = undoDrawing;
document.getElementById('svgRedoBtn').onclick = redoDrawing;

// Save initial state
saveDrawingState();

// Initialize the viewBox for zoom functionality
updateViewBox();

  // --- Glass Order PDF Generation (SD50) ---
  // A tiny 1x1 transparent PNG used as the logo in the glass order PDF.
  // We use a small placeholder here to keep the HTML file size reasonable; the PDF footer will still show a subtle logo block.
  const OPUS_LOGO_SMALL =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAASsJTYQAAAAASUVORK5CYII=';

  const orderPdfBtn = document.getElementById('orderPdfBtn');
  if (orderPdfBtn) {
    orderPdfBtn.onclick = async () => {
      // Ensure calculation has been run
      if (!Array.isArray(layouts) || layouts.length === 0) {
        alert('Please calculate first');
        return;
      }
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();

      // Determine glass note from thickness selection
      const glassThkEl = document.getElementById('glassThk');
      const glassThkVal = glassThkEl && glassThkEl.value ? glassThkEl.value : '';
      let glassTypeName = '';
      if (glassThkVal === '13.52' || glassThkVal === '17.52') {
        glassTypeName = 'Sentry Laminate';
      } else if (glassThkVal) {
        glassTypeName = 'Toughened';
      }
      const glassNote = glassThkVal ? `${glassThkVal}mm ${glassTypeName}` : '';

      // Compute order height (FFL + 50mm)
      // Retrieve glass height element safely without using optional chaining for older browser compatibility
      const htEl = document.getElementById('glassHt');
      const fflStr = (htEl && htEl.value) ? htEl.value : '0';
      const fflHeight = parseInt(fflStr, 10) || 0;
      const glassHeightOrder = fflHeight + 50;

      // Build map of unique panel/gate widths
      const uniqueMap = {};
      layouts.forEach((lay) => {
        if (Array.isArray(lay.panelWidths)) {
          lay.panelWidths.forEach((pw) => {
            const key = `panel_${pw}`;
            if (uniqueMap[key]) uniqueMap[key].count++;
            else uniqueMap[key] = { width: pw, type: 'panel', count: 1 };
          });
        }
        if (lay.gateSegment) {
          const gWidth = lay.gateSegment.totalWidth || lay.gateSegment.width || 905;
          const key = `gate_${gWidth}`;
          if (uniqueMap[key]) uniqueMap[key].count++;
          else uniqueMap[key] = { width: gWidth, type: 'gate', count: 1 };
        }
      });
      const uniquePanels = Object.values(uniqueMap);
      uniquePanels.sort((a, b) => b.width - a.width);

      // Helper to draw header and info box on each page
      function drawHeaderAndInfo() {
        const barW = pageWidth - 120;
        const barH = 40;
        const barX = (pageWidth - barW) / 2;
        const barY = 0;
        const barR = 20;
        pdf.setFillColor(0, 0, 0);
        pdf.roundedRect(barX, barY, barW, barH, barR, barR, 'F');
        pdf.setTextColor(255, 255, 255);
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(20);
        pdf.text('Opus Hardware – SD50 Glass Order', pageWidth / 2, barY + 27, { align: 'center' });
        pdf.setTextColor(17, 17, 17);
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(12);
        const infoX = 40;
        const infoY = barY + barH + 20;
        const infoW = pageWidth - 80;
        const infoH = 70;
        pdf.setDrawColor(234, 234, 234);
        pdf.setFillColor(255, 255, 255);
        pdf.roundedRect(infoX, infoY, infoW, infoH, 8, 8, 'FD');
        const shapeLabel = curShape && curShape.label ? curShape.label : 'Unknown';
        const totalRun = sideLens.reduce((a, b) => a + b, 0);
        pdf.text(`Shape: ${shapeLabel}`, infoX + 20, infoY + 20);
        pdf.text(`Total Run: ${totalRun} mm`, infoX + 20, infoY + 36);
        if (glassNote) {
          pdf.text(`Glass: ${glassNote}`, infoX + 20, infoY + 52);
        }
        return infoY + infoH + 20;
      }

      let currentY = drawHeaderAndInfo();
      const rectW = 300;
      const rectH = 80;
      const rowGap = 40;

      uniquePanels.forEach((panel) => {
        if (currentY + rectH > pageHeight - 80) {
          pdf.addPage();
          currentY = drawHeaderAndInfo();
        }
        const rectX = 60;
        const rectY = currentY;
        if (panel.type === 'gate') {
          pdf.setFillColor(198, 231, 198);
        } else {
          pdf.setFillColor(200, 220, 255);
        }
        pdf.setDrawColor(160, 160, 160);
        pdf.rect(rectX, rectY, rectW, rectH, 'FD');
        const arrowY = rectY - 12;
        const arrowSize = 6;
        pdf.setDrawColor(0, 0, 0);
        pdf.setLineWidth(1);
        pdf.line(rectX, arrowY, rectX + rectW, arrowY);
        pdf.line(rectX, arrowY, rectX + arrowSize, arrowY - arrowSize / 2);
        pdf.line(rectX, arrowY, rectX + arrowSize, arrowY + arrowSize / 2);
        pdf.line(rectX + rectW, arrowY, rectX + rectW - arrowSize, arrowY - arrowSize / 2);
        pdf.line(rectX + rectW, arrowY, rectX + rectW - arrowSize, arrowY + arrowSize / 2);
        const widthLabel = panel.type === 'gate' ? 890 : panel.width;
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'normal');
        pdf.setTextColor(20, 20, 20);
        pdf.text(`${widthLabel}mm`, rectX + rectW / 2, arrowY - 3, { align: 'center' });
        if (panel.type === 'gate') {
          pdf.setFontSize(14);
          pdf.setFont('helvetica', 'bold');
          pdf.setTextColor(60, 60, 60);
          pdf.text('Gate Panel', rectX + rectW / 2, rectY + rectH / 2 + 4, { align: 'center' });
        }
        if (panel.count > 0) {
          const qtyX = rectX + rectW + 10;
          const qtyY = rectY + rectH / 2 + 5;
          pdf.setFontSize(22);
          pdf.setFont('helvetica', 'bold');
          pdf.setTextColor(255, 0, 0);
          pdf.text(`x${panel.count}`, qtyX, qtyY);
        }
        currentY += rectH + rowGap;
      });
      // Footer
      const footY = pageHeight - 50;
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(100, 100, 100);
      pdf.text('Generated by Opus Hardware SD50 Designer', 40, footY);
      const imgSize = 80;
      pdf.addImage(OPUS_LOGO_SMALL, 'PNG', pageWidth - imgSize - 40, footY - imgSize + 20, imgSize, imgSize);
      pdf.save('Opus_SD50_GlassOrder.pdf');
    };
  }

  </script>

  <!-- Vista Channel PS1 override: define height limits for balustrade and pool fences -->
  <script>
  (function() {
    // Ensure PS1 object exists
    window.PS1 = window.PS1 || {};
    PS1.balustrade = PS1.balustrade || {};
    PS1.pool = PS1.pool || {};
    // Balustrade height limits for Vista channel. Heights from 1000mm to 1600mm in 50 mm increments.
    // Each entry marks a height as allowed (400) or disallowed (999) for a given wind zone.
    PS1.balustrade.internal = {
      '12': {
        '1000': {L:400,M:400,H:400,VH:400,EH:400},
        '1050': {L:400,M:400,H:400,VH:400,EH:400},
        '1100': {L:400,M:400,H:400,VH:400,EH:400},
        '1150': {L:400,M:400,H:400,VH:999,EH:999},
        '1200': {L:400,M:400,H:999,VH:999,EH:999},
        '1250': {L:400,M:400,H:999,VH:999,EH:999},
        '1300': {L:999,M:999,H:999,VH:999,EH:999},
        '1350': {L:999,M:999,H:999,VH:999,EH:999},
        '1400': {L:999,M:999,H:999,VH:999,EH:999},
        '1450': {L:999,M:999,H:999,VH:999,EH:999},
        '1500': {L:999,M:999,H:999,VH:999,EH:999},
        '1550': {L:999,M:999,H:999,VH:999,EH:999},
        '1600': {L:999,M:999,H:999,VH:999,EH:999}
      },
      '13.52': {
        '1000': {L:400,M:400,H:400,VH:400,EH:400},
        '1050': {L:400,M:400,H:400,VH:400,EH:400},
        '1100': {L:400,M:400,H:400,VH:400,EH:400},
        '1150': {L:400,M:400,H:400,VH:400,EH:999},
        '1200': {L:400,M:400,H:400,VH:400,EH:999},
        '1250': {L:400,M:400,H:400,VH:400,EH:999},
        '1300': {L:400,M:400,H:400,VH:999,EH:999},
        '1350': {L:999,M:999,H:999,VH:999,EH:999},
        '1400': {L:999,M:999,H:999,VH:999,EH:999},
        '1450': {L:999,M:999,H:999,VH:999,EH:999},
        '1500': {L:999,M:999,H:999,VH:999,EH:999},
        '1550': {L:999,M:999,H:999,VH:999,EH:999},
        '1600': {L:999,M:999,H:999,VH:999,EH:999}
      },
      '15': {
        '1000': {L:400,M:400,H:400,VH:400,EH:400},
        '1050': {L:400,M:400,H:400,VH:400,EH:400},
        '1100': {L:400,M:400,H:400,VH:400,EH:400},
        '1150': {L:400,M:400,H:400,VH:400,EH:400},
        '1200': {L:400,M:400,H:400,VH:400,EH:400},
        '1250': {L:400,M:400,H:400,VH:400,EH:400},
        '1300': {L:400,M:400,H:400,VH:400,EH:400},
        '1350': {L:400,M:400,H:400,VH:400,EH:999},
        '1400': {L:400,M:400,H:400,VH:999,EH:999},
        '1450': {L:999,M:999,H:999,VH:999,EH:999},
        '1500': {L:999,M:999,H:999,VH:999,EH:999},
        '1550': {L:999,M:999,H:999,VH:999,EH:999},
        '1600': {L:999,M:999,H:999,VH:999,EH:999}
      },
      '17.52': {
        '1000': {L:400,M:400,H:400,VH:400,EH:400},
        '1050': {L:400,M:400,H:400,VH:400,EH:400},
        '1100': {L:400,M:400,H:400,VH:400,EH:400},
        '1150': {L:400,M:400,H:400,VH:400,EH:400},
        '1200': {L:400,M:400,H:400,VH:400,EH:400},
        '1250': {L:400,M:400,H:400,VH:400,EH:400},
        '1300': {L:400,M:400,H:400,VH:400,EH:400},
        '1350': {L:400,M:400,H:400,VH:400,EH:999},
        '1400': {L:400,M:400,H:400,VH:999,EH:999},
        '1450': {L:999,M:999,H:999,VH:999,EH:999},
        '1500': {L:999,M:999,H:999,VH:999,EH:999},
        '1550': {L:999,M:999,H:999,VH:999,EH:999},
        '1600': {L:999,M:999,H:999,VH:999,EH:999}
      }
    };
    // Pool height limits for Vista channel. Heights from 1200mm to 1550mm in 50 mm increments.
    PS1.pool.overhang = { '12': 500, '15': 500 };
    // Define pool height limits for Vista channel. Heights are in 50 mm increments
    // and set to 400 for allowed combinations or 999 for disallowed ones.
    PS1.pool.internal = {
      '12': {
        // 12 mm pool: Low/Medium allow 1200–1350; High allows 1200–1250; Very High allows 1200; Extra High not allowed
        '1200': {L:400,M:400,H:400,VH:400,EH:999},
        '1250': {L:400,M:400,H:400,VH:999,EH:999},
        '1300': {L:400,M:400,H:999,VH:999,EH:999},
        '1350': {L:400,M:400,H:999,VH:999,EH:999},
        // heights above 1350 are disallowed for 12 mm pool
        '1400': {L:999,M:999,H:999,VH:999,EH:999},
        '1450': {L:999,M:999,H:999,VH:999,EH:999},
        '1500': {L:999,M:999,H:999,VH:999,EH:999},
        '1550': {L:999,M:999,H:999,VH:999,EH:999}
      },
      '15': {
        // 15 mm pool: Low/Medium allow 1200–1500; High allows 1200–1400; Very High and Extra High allow 1200–1300
        '1200': {L:400,M:400,H:400,VH:400,EH:400},
        '1250': {L:400,M:400,H:400,VH:400,EH:400},
        '1300': {L:400,M:400,H:400,VH:400,EH:400},
        '1350': {L:400,M:400,H:400,VH:999,EH:999},
        '1400': {L:400,M:400,H:400,VH:999,EH:999},
        '1450': {L:400,M:400,H:999,VH:999,EH:999},
        '1500': {L:400,M:400,H:999,VH:999,EH:999},
        // heights above 1500 are disallowed for Vista pool 15 mm
        '1550': {L:999,M:999,H:999,VH:999,EH:999}
      }
    };
  })();

  // Initialise gap options and UI for Glass Mode. Set up event listeners.
  if (typeof updateGapOptions === 'function') {
    updateGapOptions();
  }
  if (typeof updateGlassModeUI === 'function') {
    updateGlassModeUI();
  }
  // Update gap options whenever the fence type changes
  const _fenceEl = $('fenceType');
  if (_fenceEl) _fenceEl.addEventListener('change', updateGapOptions);
  // Update UI when glass mode is toggled
  const _glassEl = $('glassType');
  if (_glassEl) _glassEl.addEventListener('change', updateGlassModeUI);

  </script>


</body>
